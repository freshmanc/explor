\section{Prefix}\label{prefix}
The code of a compiled \desi\ program is enveloped between a prologue in \texttt{prefix.tex} and an epilogue in \texttt{postfix.tex}, both of which are \dvmasm\ scripts. This section of the document is the start of the prologue.
The first code planted by the prologue is a jump to the \emph{controller} which is in the epilogue. The controller must follow everything else as it depends on constants planted by the \jit\ compiler (see \xs{framework}.)

{\small
\begin{verbatim}
    jmp controller
\end{verbatim}}



\subsection{Pervasive constants}
We declare Boolean constants to match the values adopted by the \cc\ compiler we are using.

\begin{tabbing}
\indents
\vb\>\textbf{constant} \textsc{False} \textbf{is} 0;\\
\vb\>\textbf{constant} \textsc{True} \textbf{is} 1;\\
\\[-30pt]
\end{tabbing}

{\small
\begin{verbatim}
FALSE  equ 0
TRUE   equ 1
\end{verbatim}}

To ease the path to a 64-bit realisation, $BpW$ declares the number of bytes in a word. For the moment the value of $BpW$ is four, but it will be eight eventually. Variables that could be integers or reals are allocated eight bytes anyway (by $BpV$) even if they use only four. This policy simplifies references to the arguments of processes and routines; argument $g$ is at position $BpV\!\times g$ whatever the size of any arguments that precede it.

{\small
\begin{verbatim}
BpW  equ  4  % Bytes per Word
BpV  equ  8  % Bytes per variable
WpV  equ  2  % Words per variable
\end{verbatim}}

Because bytes per word and variable are powers of two, we define some other constants that enable us to employ shifts rather than divisions. For example, $(x+\emph{BpW}-1)/\emph{BpW}$ can be encoded as $(x+\emph{MaxBiW})\gg \emph{BpWBits}$.

{\small
\begin{verbatim}
MaxBiW   equ  3  % Maximum byte index within word
BpWBits  equ  2  % Bits needed for byte index within word 
MaxBiV   equ  7  % Maximum byte index within variable
BpVBits  equ  3  % Bits needed for byte index within variable
WpVBits  equ  1  % Bits needed for word index within variable
\end{verbatim}}

We provide short-hands for word offsets.

{\small
\begin{verbatim}
W0   equ  0*BpW
W1   equ  1*BpW
W2   equ  2*BpW
W3   equ  3*BpW
W4   equ  4*BpW
W5   equ  5*BpW
W6   equ  6*BpW
W7   equ  7*BpW
W8   equ  8*BpW
W9   equ  9*BpW
W10  equ 10*BpW
W11  equ 11*BpW
W12  equ 12*BpW
W13  equ 13*BpW
W14  equ 14*BpW
W15  equ 15*BpW
\end{verbatim}}



\subsection{Extracode Parameters}
The stack of an extracode with local variables $i$, $j$ and $k$ and with arguments $a$ and $b$ has the following layout, where an asterisk represents the return link.

$$i,  j,  k, *,  a,  b$$

Macro \emph{enter(b)} is invoked at the start of each extracode to adjust the stack to allow for $b$ bytes of local stack space. For example, \emph{enter(W3)}.
The macro sets a copy of the adjusted stack pointer into the \texttt{dx} register.

{\small
\begin{verbatim}
enter   mac 1             % MAC enter(b)
        alc $0            %    allocate b bytes of stack
        mvw dx sp         %    dx := adjusted stack pointer
        end               % END.
\end{verbatim}}

Exit from an extracode is made by macro \emph{leave(b,t)} where $b$ is as for entry and $t$ is the total number of stack bytes occupied by the extracode; that is, the space occupied by locals, the link and the arguments. For example, \emph{leave(W3,W6)}. The macro destroys register \texttt{bx} but leaves a result in \texttt{ax} unchanged.

{\small
\begin{verbatim}
leave   mac 2             % MAC leave(b, t)
        mvw bx [sp + $0]  %    bx := return link;
        dlc $1            %    deallocate t bytes of stack;
        jmp bx            %    RETURN
        end               % END.
\end{verbatim}}



\subsection{Externals}\label{externals}

The special-purpose registers \texttt{tp} (pointing to the current thread control-block, or \emph{TCB}) and \texttt{pp} (pointing to the current process frame) are protected during execution of an external routine. (The base pointer \texttt{bp} is adjusted separately.) The general purpose registers, \texttt{ax}, \texttt{bx}, \texttt{cx} and \texttt{dx} are not protected. Macro \textit{protect()} protects the values of the special-purpose registers and macro \textit{recover()} recovers them.


{\small
\begin{verbatim}
protect  mac 0    % MAC protect()
         psh tp   %    protect thread pointer
         psh pp   %    protect process pointer;
         end      % END.
\end{verbatim}}

{\small
\begin{verbatim}
recover  mac 0    % MAC recover()
         pop pp   %    recover process pointer
         pop tp   %    recover thread pointer;
         end      % END.
\end{verbatim}}

Macro \textit{protect\_all()} protects the values of all registers and macro \textit{recover\_all()} recovers them.


{\small
\begin{verbatim}
protect_all  mac 0    % MAC protect_all()
             psh dx   %    protect dx;
             psh cx   %    protect cx;
             psh bx   %    protect bx;
             psh ax   %    protect ax
             protect  %    protect special-purpose registers;
             end      % END.
\end{verbatim}}

{\small
\begin{verbatim}
recover_all  mac 0    % MAC recover_all()
             recover  %    recover special-purpose registers
             pop ax   %    recover ax;
             pop bx   %    recover bx;
             pop cx   %    recover cx;
             pop dx   %    recover dx;
             end      % END.
\end{verbatim}}



To invoke an external routine, we first protect the special-purpose registers \texttt{pp} and \texttt{tp} by pushing them onto the stack. We assume that the only registers preserved inside an external are \texttt{bp} and \texttt{sp}. We then push the values of input arguments onto the stack, employing the \cc\ conventions for ordering. After calling the external routine we adjust the stack pointer to remove the inputs, store any returned result, and finally restore the special-purpose registers. Macros \textit{ext0} to \textit{ext4} provide shorthands.

{\small
\begin{verbatim}
ext0     mac 1    % MAC ext0($0 e)
         protect  %    protect();
         inv $0   %    e();
         recover  %    recover()
         end      % END.
\end{verbatim}}

{\small
\begin{verbatim}
ext1     mac 2      % MAC ext1($0 e, $1 p)
         protect    %    protect();
         inv $0 $1  %    e(p);
         dlc W1     %
         recover    %    recover()
         end        % END.
\end{verbatim}}

{\small
\begin{verbatim}
ext2     mac 3         % MAC ext2($0 e, $1 p, $2 q)
         protect       %    protect();
         inv $0 $1 $2  %    e(p, q);
         dlc W2        %
         recover       %    recover()
         end           % END.
\end{verbatim}}

{\small
\begin{verbatim}
ext3     mac 4            % MAC ext3($0 e, $1 p, $2 q, $3 r)
         protect          %    protect();
         inv $0 $1 $2 $3  %    e(p, q, r);
         dlc W3           %
         recover          %    recover()
         end              % END.
\end{verbatim}}

{\small
\begin{verbatim}
ext4     mac 5               % MAC ext4($0 e, $1 p, $2 q, $3 r, $3 s)
         protect             %    protect();
         inv $0 $1 $2 $3 $4  %    e(p, q, r, s);
         dlc W4              %
         recover             %    recover()
         end                 % END.
\end{verbatim}}

Macros \textit{log0} through \textit{log4} are similar to macros \textit{ext0} through \textit{ext4}, but save and restore all registers. They are typically employed by the diagnostic intrinsics. (See \xs{diagnostics} below.)

{\small
\begin{verbatim}
log0     mac 1        % MAC log0($0 e)
         protect_all  %    protect_all();
         inv $0       %    e();
         recover_all  %    recover_all()
         end          % END.
\end{verbatim}}

{\small
\begin{verbatim}
log1     mac 2        % MAC log1($0 e, $1 p)
         protect_all  %    protect_all();
         inv $0 $1    %    e(p);
         dlc W1       %
         recover_all  %    recover_all()
         end          % END.
\end{verbatim}}

{\small
\begin{verbatim}
log2     mac 3         % MAC log2($0 e, $1 p, $2 q)
         protect_all   %    protect_all();
         inv $0 $1 $2  %    e(p, q);
         dlc W2        %
         recover_all   %    recover_all()
         end           % END.
\end{verbatim}}

{\small
\begin{verbatim}
log3     mac 4            % MAC log3($0 e, $1 p, $2 q, $3 r)
         protect_all      %    protect_all();
         inv $0 $1 $2 $3  %    e(p, q, r);
         dlc W3           %
         recover_all      %    recover_all()
         end              % END.
\end{verbatim}}

{\small
\begin{verbatim}
log4     mac 5               % MAC log3($0 e, $1 p, $2 q, $3 r, $3 s)
         protect_all         %    protect_all();
         inv $0 $1 $2 $3 $4  %    e(p, q, r, s);
         dlc W4              %
         recover_all         %    recover_all()
         end                 % END.
\end{verbatim}}



\subsection{Intrinsics}\label{intrinsics}
In addition to library routines that the \desi\ programmer is aware of, there exists a set of external routines that supplement the code planted by the compiler. We refer to these as \emph{intrinsics}.



\subsubsection{Diagnostics}\label{diagnostics}
Intrinsics such as \emph{logT} and \emph{logTT} provide diagnostic help.
By invoking them with the appropriate macro such as \emph{log1} or \emph{log2} these invocations can be inserted anywhere in the code without effecting registers, stack or store. For example `\texttt{log1~logT~\emph{t}}' to display the text labelled \texttt{\emph{t}}.

\begin{tabbing}
\indents
\\[-10pt]
\rem{Write \emph{t} to log.}
\xtn{logT}{t: Text}
\\[-10pt]
\rem{Write \emph{t//v} to log.}
\xtn{logTT}{t, v: Text}
\\[-10pt]
\rem{Write \emph{t//Text(i)} to log.}
\xtn{logTI}{t: Text; i: Word}
\\[-10pt]
\rem{Write \emph{t//Hex(i)} to log.}
\xtn{logTH}{t: Text; i: Word}
\\[-10pt]
\rem{Write \emph{t//r} to log, where Real \emph{r} is at address \emph{i}.}
\xtn{logTR}{t: Text; i: Word}
\\[-10pt]
\rem{Write \emph{t//length(q)} to log.}
\xtn{logTQ}{t: Text; q: Queue}
\\[-10pt]
\rem{Write \emph{t // names of processes} to log.}
\xtn{logPQ}{t: Text; q: Queue}
\\[-10pt]
\rem{Write first \textit{n} words of stack to log.}
\xtn{logStack}{n: Word}
\\[-10pt]
\rem{Write a trace message for the file-name-line triple at address \textit{p} to log.}
\xtn{logTrace}{p: DataAddress}
\\[-10pt]
\rem{Write r to log and cease execution.}
\xtn{dvm\_comp\_fail}{r: String}
\\[-30pt]
\end{tabbing}

{\small
\begin{verbatim}
logT           ext  "logT"
logTT          ext  "logTT"
logTI          ext  "logTI"
logTH          ext  "logTH"
logTR          ext  "logTR"
logTQ          ext  "logTQ"
logPQ          ext  "logPQ"
logStack       ext  "logStack"
logTrace       ext  "logTrace"
dvm_comp_fail  ext  "dvm_comp_fail"
\end{verbatim}}

\subsubsection{Assertions}\label{assertions}
Macros \emph{assert}, \emph{assert\_equal} and \emph{assert\_not\_equal} enable assertions to be included.

{\small
\begin{verbatim}
% MAC assert(b: Boolean;  m: String): unless b, report m and cease.
assert          mac 2
                cmp $0 TRUE
                jeq _1
                ext1 dvm_comp_fail $1
_1              nix
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC assert_equal(x, y: Word;  m: String): unless x=y, report m and cease.
assert_equal    mac 3
                cmp $0 $1
                jeq _1
                ext1 dvm_comp_fail $2
_1              nix
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC assert_not_equal(x, y: Word;  m: String): unless x<>y, report m and cease.
assert_not_equal  mac 3
                  cmp $0 $1
                  jne _1
                  ext1 dvm_comp_fail $2
_1                nix
                  end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC assert_zero(x: Word;  m: String): unless x=0, report m and x, and cease.
non_zero_fail   txt "Zero-assertion failure: "
assert_zero     mac 2
                cmp $0 0
                jeq _1
                ext2 logTI non_zero_fail $0
                ext1 dvm_comp_fail $1
_1              nix
                end
\end{verbatim}}



\subsubsection{Moves}
\begin{tabbing}
\indents
\rem{Move $n$ bytes from location $q$ to location $p$.}
\rtn{copyBytes}{p, q: Byte[]; n: i32}
\ooooo{\key{for} i := 0 to n-1 \key{do}}
\ooooooo{p[i] := q[i]}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD copyBytes(p, q, n)          % [* p q n] zaps all registers
copyBytes  enter W0               % [0 1 2 3]
           mvw ax [dx + 3*BpW]    % ax n
           mvw bx [dx + 1*BpW]    % bx p
           mvw cx [dx + 2*BpW]    % cx q
_1         cmp ax 0
           jeq _2
           mzb dx [cx]
           inc cx
           mvb [bx] dx
           inc bx
           dec ax
           jmp _1
_2         leave W0 W4
           end
\end{verbatim}}


\subsubsection{Blocks}
Intrinsics \emph{dvm\_new\_block}, \emph{dvm\_zero\_block} and \emph{dvm\_discard\_block} relate to storage. A \emph{Block} is the address of a sequence of words, served from the heap. A block has a length (in words) and also an \emph{owner} which is a \emph{Thread} (which is itself another block.) Type \emph{Thread} is declared in \xs{structuredtypes} below.\footnote{Unlike earlier versions of the scheduling logic, the block-allocating externals include caching logic based not only on the length of each block but also on the value of the thread---the address of the 'owner'---thus providing an approximation to a cache-per-thread.}

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Block} \textbf{is} \emph{Word};\\
\\[-10pt]
\rem{Yield a new block of \emph{n} words with owner~\emph{t}.}
\xtn{dvm\_new\_block}{t: Thread; n: Word $\rightarrow$ Block}
\\[-10pt]
\rem{Yield a new block of \emph{n} zeroed words with owner~\emph{t}.}
\xtn{dvm\_zero\_block}{t: Thread; n: Word $\rightarrow$ Block}
\\[-10pt]
\rem{Discard block \emph{b}.}
\xtn{dvm\_discard\_block}{b:~Block}
\\[-30pt]
\end{tabbing}

{\small
\begin{verbatim}
dvm_new_block      ext  "dvm_new_block"
dvm_zero_block     ext  "dvm_zero_block"
dvm_discard_block  ext  "dvm_discard_block"
\end{verbatim}}

Types based on blocks, such as threads and processes, are considered to be subtypes of Type \emph{Block}. (See the \textbf{isa}-clauses in the declarations of \xs{structuredtypes}.) This convention simplifies arguments of Type \emph{Block}. For example, we can write `\emph{dvm\_discard\_block(p)}', where \emph{p} is a process, rather than `\emph{dvm\_discard\_block(Block(p))}', a circumlocution that explicates the generalisation from Process to Block.

A block occupies three more words of space in the heap than its declared length indicates. The extra words precede the block address and contain the length, the owner and space for a pointer when blocks are linked together to form \emph{queues}---which are the subject of the next section.



\subsubsection{Queues}
Intrinsics relating to queues of blocks are \emph{dvm\_new\_queue}, \emph{dvm\_empty\_queue}, \emph{dvm\_write\_queue}, \emph{dvm\_move\_queue}, \emph{dvm\_read\_queue} and \emph{dvm\_discard\_queue}.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Queue} \textbf{is} \emph{Word};\\
\\[-10pt]
\rem{Yield a new queue with owner \emph{t}.}
\xtn{dvm\_new\_queue}{Thread t $\rightarrow$ Queue}
\\[-10pt]
\rem{Yield whether q is empty.}
\xtn{dvm\_empty\_queue}{q: Queue $\rightarrow$ Boolean}
\\[-10pt]
\rem{Append \emph{b} to \emph{q}.}
\xtn{dvm\_write\_queue}{q: Queue; b: Block}
\\[-10pt]
\rem{Move \emph{p} to back of \emph{q}. Yield whether resulting \emph{q} is non-empty.}
\xtn{dvm\_move\_queue}{q: Queue; p: Queue $\rightarrow$ Boolean}
\\[-10pt]
\rem{Yield block popped from front of non-empty \emph{q}.}
\xtn{dvm\_read\_queue}{q: Queue $\rightarrow$ b: Block}
\\[-10pt]
\rem{Discard empty \emph{q}.}
\xtn{dvm\_discard\_queue}{q: Queue}
\\[-30pt]
\end{tabbing}

{\small
\begin{verbatim}
dvm_new_queue      ext  "dvm_new_queue"
dvm_empty_queue    ext  "dvm_empty_queue"
dvm_write_queue    ext  "dvm_write_queue"
dvm_move_queue     ext  "dvm_move_queue"
dvm_read_queue     ext  "dvm_read_queue"
dvm_discard_queue  ext  "dvm_discard_queue"
\end{verbatim}}

Macro \emph{cmp\_queue\_head(q)} provides an in-line alternative to \emph{dvm\_empty\_queue}. It compares the head of the queue whose address is \emph{q} with zero and sets the condition register accordingly. A queue is empty if and only if its head is zero.

{\small
\begin{verbatim}
QUEUE_LINK        equ -W1
cmp_queue_head    mac 1
                  mvw dx $0
                  cmp [dx + QUEUE_LINK] 0
                  end
\end{verbatim}}




\subsubsection{Mutexes and Conditions}
\xs{threadmonitor} below describes how a monitor is employed to control the flow of work to threads, and their suspension when no work is available. To implement a monitor we need a lock and a `condition variable'---a queue on which threads can wait until a certain condition becomes true. A monitor lock is a \emph{Mutex} (actually a \emph{pthreads\_mutex\_t}) and a condition queue is a \emph{Condition} (actually a \emph{pthreads\_cond\_t}) each of which occupy one word.


\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Mutex} \textbf{is} \emph{Word};\\
\vb\>\textbf{type} \emph{Condition} \textbf{is} \emph{Word};\\[-17pt]
\end{tabbing}

\begin{tabbing}
\indents
\rem{Initialise \emph{m}}
\vb\>\textbf{intrinsic} \emph{init\_mutex}(\emph{m}: \textbf{ref} \emph{Mutex}); \\
\rem{Lock \emph{m}}
\vb\>\textbf{intrinsic} \emph{lock\_mutex}(\emph{m}: \textbf{ref} \emph{Mutex}); \\
\rem{Unlock \emph{m}}
\vb\>\textbf{intrinsic} \emph{unlock\_mutex}(\emph{m}: \textbf{ref} \emph{Mutex});
\end{tabbing}

{\small
\begin{verbatim}
%init_mutex      ext  "init_mutex"
%lock_mutex      ext  "lock_mutex"
%unlock_mutex    ext  "unlock_mutex"
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Initialise \emph{c}}
\vb\>\textbf{intrinsic} \emph{new\_condition}($\rightarrow$ \emph{Condition}); \\
\rem{Wait on \emph{c}}
\vb\>\textbf{intrinsic} \emph{wait\_on\_condition}(\emph{c}: \emph{Condition}); \\
\rem{Signal \emph{c}}
\vb\>\textbf{intrinsic} \emph{signal\_condition}(\emph{c}: \emph{Condition});
\end{tabbing}

{\small
\begin{verbatim}
new_condition       ext  "new_condition"
wait_on_condition   ext  "wait_on_condition"
signal_condition    ext  "signal_condition"
\end{verbatim}}

It is important to be aware that sometimes, on a multi-processor computer, a condition may sometimes be signalled for reasons other than execution of routine \emph{signal\_condition}.\footnote{I do not know why this is the case nor the precise circumstances in which it can take place. I believe it has something to do with avoiding complications in processor caches, but I am not sure.} To allow for this apparently rare event, routine \emph{wait\_on\_condition} must be embedded in a loop that checks whether the desired condition has actually been met.


\subsubsection{Locks}

A \emph{SpinLock} is either locked or unlocked.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{SpinLock} \textbf{is} \textsc{Locked} $|$ \textsc{Unlocked};
\end{tabbing}

{\small
\begin{verbatim}
LOCKED    equ  0
UNLOCKED  equ  1
\end{verbatim}}

Operations on a spinlock are \emph{lock} and \emph{unlock}. If a thread locks a locked spinlock, the thread sits in a busy wait until the spinlock is unlocked by another thread. It is an error to unlock an unlocked spinlock.

\begin{tabbing}
\indents
\rem{Lock \emph{k}.}
\mac{lock}{k: SpinLock}
\ooooo{v := 0;}
\ooooo{\key{while} atomic-exchange(v, k) = 0 \key{do skip end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC lock($0 k) -- destroys cx; k must not depend on cx.
%lockcall txt "lock: "
lock    mac 1      %
        %log2 logTH lockcall $0
        zer cx     % cx v
_1      axc cx $0  %
        jcz _1     %
        end        %
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Unlock \emph{k}.}
\mac{unlock}{k: SpinLock}
\ooooo{\key{assert} k $\neq$ \textsc{Unlocked};}
\ooooo{atomic-inc(k)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC unlock($0 k) -- destroys cx;  k must not depend on cx.
bad_unlock  utf "Unlock(UNLOCKED)"
%unlockcall  txt "unlock: "
unlock      mac 1
            %log2 logTH unlockcall $0
            mvw cx $0
            anc $0
            assert_not_equal cx UNLOCKED bad_unlock
            end
\end{verbatim}}

In pseudo-code the phrase `\textbf{with} \textbf{lock} \emph{k} \textbf{do} \dots\ \textbf{end}' is equivalent to `\emph{lock}(\emph{k}); \dots; \emph{unlock}(\emph{k})'.





\subsubsection{Monitors}

Macros \emph{enter\_monitor}, \emph{await}, \emph{signal} and \emph{leave\_monitor} enable writing of a monitor.

\begin{tabbing}
\indents
\rem{Enter monitor expressed as an extracode with \emph{n} words of local space.}
\rem{The address of the monitor's thread is word \emph{t} of the extracode.}
\mac{enter\_monitor}{n, t: Word}
\ooooo{\key{enter} n;}
\ooooo{lock(t.threadLock)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
enter_monitor     mac 2
                  enter $0
                  mvw ax [sp+$1]
                  lock [ax+THREAD_LOCK]
                  end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Wait on the thread's condition variable.}
\rem{The address of the monitor's thread is word \emph{t} of the extracode.}
\mac{await}{t: Word}
\ooooo{unlock(t.threadLock);}
\ooooo{wait\_on\_condition(t.threadQueue)}
\ooooo{lock(t.threadLock)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
await           mac 1
                mvw ax [sp+$0]
                unlock [ax+THREAD_LOCK]
                ext1 wait_on_condition [ax+THREAD_QUEUE]
                mvw ax [sp+$0]
                lock [ax+THREAD_LOCK]
                end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Signal the thread's condition variable.}
\rem{The address of the monitor's thread is word \emph{t} of the extracode.}
\mac{signal}{t: Word}
\ooooo{signal\_condition(t.threadQueue)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
signal          mac 1
                mvw ax [sp+$0]
                ext1 signal_condition [ax+THREAD_QUEUE]
                end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Leave monitor expressed as an extracode with \emph{n} words of local space and \emph{s} words }
\rem{of stack space in total. The address of the monitor's thread is word \emph{t}.}
\rem{Preserve possible extracode result in ax register.}
\mac{leave\_monitor}{n, s, t: Word}
\ooooo{unlock(t.threadLock);}
\ooooo{\key{leave} n, s}
\fin
\end{tabbing}

{\small
\begin{verbatim}
leave_monitor   mac 3
                mvw bx [sp+$2]
                unlock [bx+THREAD_LOCK]
                leave $0 $1
                end
\end{verbatim}}




\subsubsection{Texts}
Intrinsics \textit{dvm\_empty\_text}, \textit{dvm\_text\_int}, \textit{dvm\_text\_cat} and \textit{dvm\_discard\_text} provide support for \desi\  texts.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Text} \textbf{is} \emph{DataAddress};\\
\\[-10pt]
\rem{Yield the address of a newly allocated empty text.}
\xtn{dvm\_empty\_text}{$\rightarrow$ Text}
\\[-10pt]
\rem{Yield the address of a newly allocated text with content s.}
\xtn{dvm\_new\_text}{s: String $\rightarrow$ Text}
\\[-10pt]
\rem{Replace \textit{t} with \textit{i} encoded as a decimal value; in \desi\ terms, \textit{t := Text(i)}.}
\xtn{dvm\_text\_int}{t: Text; i: Word}
\\[-10pt]
\rem{Replace \emph{t} with a copy of \textit{u}; in \desi\ terms, \textit{t := u}.}
\xtn{dvm\_text\_copy}{t, u: Text}
\\[-10pt]
\rem{Replace \emph{t} with catenation of \textit{u} and \textit{v}; in \desi\ terms, \textit{t := u//v}.}
\xtn{dvm\_text\_cat}{t, u, v: Text}
\\[-10pt]
\rem{-1, 0, or +1 as \emph{t} compares with \emph{u}.}
\xtn{dvm\_cf\_text}{t, u: Text $\rightarrow$ i32}
\\[-10pt]
\rem{Recover the space occupied by \emph{t}.}
\xtn{dvm\_discard\_text}{t: Text}
\\[-30pt]
\end{tabbing}

{\small
\begin{verbatim}
dvm_empty_text    ext  "dvm_empty_text"
dvm_new_text      ext  "dvm_new_text"
dvm_text_int      ext  "dvm_text_int"
dvm_text_copy     ext  "dvm_text_copy"
dvm_text_cat      ext  "dvm_text_cat"
dvm_cf_text       ext  "dvm_cf_text"
dvm_discard_text  ext  "dvm_discard_text"
\end{verbatim}}



\subsubsection{Maps}
A \emph{WordMap} is a map with an integral domain. Such a map is similar to a dynamic array employed by the JIT compiler. It comprises a three-word vector arranged as follows:

\begin{tabbing}
\indents
\ooo{WordMap = \key{record}}
\ooooo{length: i32;}
\ooooo{capacity: i32;}
\ooooo{contents: Block}
\fin
\end{tabbing}

{\small
\begin{verbatim}
MAP_LENGTH     equ 0
MAP_CAPACITY   equ 1
MAP_CONTENTS   equ 2
\end{verbatim}}

Before defining the macros and routines that operate on maps, we present a set of primitive macros and routines that, in their turn, support map operations.

Macro \emph{newContents(n,b)} is employed when creating a new map and also when expanding one. It returns a block large enough to accomdate a vector of \emph{n} elements each of \emph{b} bytes, where \emph{b} is expressd as a log to the base two; that is, 0, 1, 2 or 3 meaning elements of size 1, 2, 4 or 8 bytes.

\begin{tabbing}
\indents
\mac{newContents}{n, b: i32 $\rightarrow$ c: Block}
\ooooo{c := dvm\_zero\_block(\key{tp}, ((n $\ll$ b) + BpW - 1) / BpW)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC newContents(n, b -> ax c)
newContents     mac 2
                mvw ax $0
                asl ax $1
                add ax MaxBiW
                asr ax BpWBits
                ext2 dvm_zero_block tp ax
                end
\end{verbatim}}

When the capacity of map~$m$ must be increased to accomodate element~$i$, macro \emph{changeCapacity(m,i)} is invoked to calculate, set and return the new capacity. The general rule is to increase the capacity by 50\%, but if that is not sufficient to accomodate element~$i$ then the capacity is set to just fit element~$i$ in.
\begin{tabbing}
\indents
\mac{changeCapacity}{m: Map, i: i32 $\rightarrow$ c: i32}
\ooooo{c := m.capacity := max(m.capacity * 3/2, i+1);}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC changeCapacity(bx m, ax i -> bx m, ax i, cx c)
changeCapacity    mac 0
                  mvw cx [bx + MAP_CAPACITY*BpW]
                  mvw dx cx
                  add cx cx
                  add cx dx
                  lsr cx 1
                  mvw dx ax
                  inc dx
                  cmp cx dx
                  jge _1
                  mvw cx dx
_1                mvw [bx + MAP_CAPACITY*BpW] cx
                  end
\end{verbatim}}

Macro \emph{growMap(m,i,b)} expands map~$m$ to at least accommodate element~$i$, where each element of the map is of size $2^b$ bytes.
\begin{tabbing}
\indents
\mac{growMap}{m: Map, i, b: i32}
\ooooo{newContents: Block := newContents(changeCapacity(m, i), b);}
\ooooo{copyBytes(m.contents, newContents, m.length $\ll$ b);}
\ooooo{dvm\_discard\_block(m.contents);}
\ooooo{m.contents := newContents;}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC growMap(b, ax i, bx m -> ax i, bx m)
growMap           mac 1
                  changeCapacity
                  psh ax
                  psh bx
                  newContents cx $0
                  pop bx                        % [i] bx m
                  psh ax                        % [newContents i]
                  psh bx                        % [m newContents i]
                  mvw cx [bx + MAP_LENGTH*BpW]  %
                  asl cx $0                     % cx := length in bytes
                  inv copyBytes ax [bx + MAP_CONTENTS*BpW] cx
                  pop bx                        % [newContents i] bx m
                  psh bx                        % [m newContents i]
                  ext1 dvm_discard_block [bx + MAP_CONTENTS*BpW]
                  pop bx                        % [newContents i] bx m
                  pop [bx + MAP_CONTENTS*BpW]   % [i]
                  pop ax                        % []
                  end
\end{verbatim}}

To avoid code bloat, extracodes are provided to expand maps whose ranges are of types Byte, Word and Real.
\begin{tabbing}
\indents
\rtnfn{growMapWB}{m: Map, i: i32}{growMap(m, i, 0)}
\rtnfn{growMapWW}{m: Map, i: i32}{growMap(m, i, BpWBits)}
\rtnfn{growMapWR}{m: Map, i: i32} {growMap(m, i, BpVBits)}
\end{tabbing}
\vspace{-17pt}

{\small
\begin{verbatim}
% XTD growMapWB(ax i, bx m -> ax i, bx m)
growMapWB  growMap 0
           ret
           end
\end{verbatim}}

{\small
\begin{verbatim}
% XTD growMapWW(ax i, bx m -> ax i, bx m)
growMapWW  growMap BpWBits
           ret
           end
\end{verbatim}}

{\small
\begin{verbatim}
% XTD growMapWR(ax i, bx m -> ax i, bx m)
growMapWR  growMap BpVBits
           ret
           end
\end{verbatim}}

When the capacity of a map has been increased, or when the length of a map
increases within its capacity, newly accessible elements must be initialised to their default values. There is a set of routines for this purpose. Each has the signature $f(m,i)$, where map~$m$ can now accomodate element $i$. Routine \emph{fillDefaultZero} is empty as it relies on allocated vectors being filled with zeros.

\begin{tabbing}
\indents
\rtn{fillDefaultZero}{m: Map, i: i32}
\ooooo{\key{skip}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XTD fillDefaultZero(ax i, bx m -> ax i, bx m)
fillDefaultZero  ret
                 end
\end{verbatim}}

\begin{tabbing}
\indents
\rtn{fillDefaultText}{m: Map, i: i32}
\ooooo{\key{for} j := m.length \key{to} i \key{do}}
\ooooooo{m.contents[j] := dvm\_empty\_text()}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XTD fillDefaultText(ax i, bx m -> ax i, bx m)
fillDefaultText  mvw cx [bx + MAP_LENGTH*BpW]    % cx j := m.length;
_1               cmp cx ax                       % C := j ~ i;
                 jgt _2                          % IF j <= i THEN
                 psh ax                          %   ; [i]
                 psh bx                          %   ; [m i]
                 psh cx                          %   ; [j m i]
                 inv dvm_empty_text              %   ax := emptyText();
                 pop cx                          %   cx := j; [m i]
                 pop bx                          %   bx := m; [i]
                 mvw dx [bx + MAP_CONTENTS*BpW]  %   dx := m.content[];
                 mvw [dx + cx*BpW] ax            %   m.contents[j] := ax;
                 pop ax                          %   ax := i; []
                 inc cx                          %   j += 1;
                 jmp _1                          % END
_2               ret
                 end
\end{verbatim}}

Extracode \emph{discardMapTexts(m)} discards the texts that comprise the range of map $m$.
\begin{tabbing}
\indents
\mac{discardMapTexts}{m: WordMap}
\ooooo{\key{for} i := 0 \key{to} m.length - 1 \key{do}}
\ooooooo{dvm\_discard\_text(m[i])}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XTC discardMapTexts(ax m)
discardMapTexts  zer bx          % bx i
_1               cmp bx [ax + MAP_LENGTH*BpW]
                 jeq _2
                 psh ax
                 psh bx
                 mvw ax [ax + MAP_CONTENTS*BpW]
                 ext1 dvm_discard_text [ax + bx*BpW]
                 pop bx                 
                 pop ax
                 inc bx
                 jmp _1
_2               ret
                 end
\end{verbatim}}

Macro~\emph{copyWordMap(p,q,b)} replaces word map $p$ with a copy of word map $q$; each has elements of size $2^b$.
\begin{tabbing}
\indents
\mac{copyWordMap}{p, q: WordMap; b: i32}
\ooooo{dvm\_discard\_block(p.contents);}
\ooooo{p.length := q.length;}
\ooooo{p.capacity := q.capacity;}
\ooooo{p.contents := newContents(p.capacity, b);}
\ooooo{copyBytes(p.contents, q.contents, p.length $\ll$ b);}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC copyWordMap(p, q, b)
copyWordMap  mac 3
             mvw cx $0                % cx p
             psh cx                   % [p]
             mvw dx $1                % dx q
             psh dx                   % [q p]
             ext1 dvm_discard_block [cx + MAP_CONTENTS*BpW]
             pop dx                   % [p]
             pop cx                   % []
             mvw [cx + MAP_LENGTH*BpW] [dx + MAP_LENGTH*BpW]
             mvw bx [dx + MAP_CAPACITY*BpW]
             mvw [cx + MAP_CAPACITY*BpW] bx
             psh cx                   % [p]
             psh dx                   % [q p]
             newContents bx $2        % ax
             pop dx                   % [p]
             pop cx                   % []
             mvw [cx + MAP_CONTENTS*BpW] ax
             mvw bx [cx + MAP_LENGTH*BpW]
             asl bx $2
             inv copyBytes ax [dx + MAP_CONTENTS*BpW] bx
             end
\end{verbatim}}

Macro~\emph{copyTextMap(p,q)} replaces word map $p$ with a copy of word map $q$; each has elements of type text.
\begin{tabbing}
\indents
\mac{copyTextMap}{p, q: WordMap}
\ooooo{discardMapTextx(p);}
\ooooo{dvm\_discard\_block(p.contents);}
\ooooo{p.length := q.length;}
\ooooo{p.capacity := q.capacity;}
\ooooo{p.contents := newContents(p.capacity, b);}
\ooooo{copyBytes(p.contents, q.contents, (p.length-1) $\ll$ b);}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC copyTextMap(p, q)
copyTextMap  mac 2
             end
\end{verbatim}}

With the above primitives in place, we can define the operations presumed by the \jit\ compiler.

\begin{tabbing}
\indents
\rem{Establish empty WordMap \emph{m} with initial capacity of \emph{n} elements each size $2^b$.}
\mac{newWordMap}{n, b: i32 $\rightarrow$ m: WordMap}
\ooooo{m := dvm\_zero\_block(\key{tp}, 3);}
\ooooo{m.length := 0;}
\ooooo{m.capacity := n;}
\ooooo{m.contents := newContents(n, b)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC newWordMap(n, b -> ax m)
newWordMap  mac 2
            ext2 dvm_zero_block tp 3
            mvw bx $0
            mvw [ax + MAP_CAPACITY*BpW] bx
            psh ax
            asl bx WpVBits
            newContents bx $1
            mvw bx ax
            pop ax
            mvw [ax + MAP_CONTENTS*BpW] bx
            end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Discard word map \emph{m}.}
\mac{discardWordMap}{m: WordMap}
\ooooo{dvm\_discard\_block(m.contents);}
\ooooo{dvm\_discard\_block(m)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC discardWordMap(ax m)
discardWordMap  mac 0
                psh ax
                ext1 dvm_discard_block [ax + MAP_CONTENTS*BpW]
                pop ax
                ext1 dvm_discard_block ax
                end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Discard text map \emph{m}.}
\mac{discardTextMap}{m: WordMap}
\ooooo{discardMapTexts(m)}
\ooooo{discardWordMap(m)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC discardTextMap(ax m)
discardTextMap  mac 0
                inv discardMapTexts
                discardWordMap
                end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Yield number of elements in map \emph{m}.}
\macfn{mapLength}{m: WordMap $\rightarrow$ n: i32}{n := m.length}
\end{tabbing}
\vspace{-17pt}

{\small
\begin{verbatim}
% MAC mapLength(ax m -> ax n)
mapLength       mac 0
                mvw ax [ax + MAP_LENGTH*BpW]
                end
\end{verbatim}}

Macro \emph{readableContent(m,i)} yields the address of the contents of WordMap~$m$, after checking that index~$i$ is in range.
\begin{tabbing}
\indents
\mac{readableContent}{m: WordMap; i: i32 $\rightarrow$ c: Block}
\ooooo{\key{if} i $<$ 0 \key{or} i $>=$ m.length \key{then} subscript\_error() \key{end};}
\ooooo{c := m.contents}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC readableContent(ax i, bx m -> ax i, bx c)
readableContent  mac 0
                 cmp ax 0
                 jlt subscript_error
                 cmp ax [bx + MAP_LENGTH*BpW]
                 jge subscript_error
                 mvw bx [bx + MAP_CONTENTS*BpW]
                 end
\end{verbatim}}

Macro \emph{writeableContent(g,f,m,i)} yields the address of the contents of WordMap~$m$, after checking that $i$ is a valid index for writing to the map. If the index is beyond the capacity of the map then the capacity is increased by invoking routine~$g(m,i)$, which might be, for example, routine \emph{growMapWW} to grow a word-to-word map. If the index is beyond the length of the map but within the capacity (as it will be after an invocation of routine~$g$) then routine~$f(m,i)$ is invoked to infill the elements up to and including element~$i$ with the default value of elements of the map.
An example of $f$ is \emph{fillDefaultZero} which is used for numeric ranges.
\begin{tabbing}
\indents
\mac{writeableContent}{g, f: \key{rtn}(Map, i32); m: WordMap; i: i32 $\rightarrow$ c: Block}
\ooooo{\key{if} i $<$ 0 \key{then} subscript\_error() \key{end};}
\ooooo{\key{if} i $>=$ m.length \key{then}}
\ooooooo{\key{if} i $>=$ m.capacity \key{then}}
\ooooooooo{g(m, i)}
\ooooooo{\key{end};}
\ooooooo{f(m, i);}
\ooooooo{m.length := i+1;}
\ooooo{\key{end};}
\ooooo{c := m.contents}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC writeableContent(growMap, fillMap, ax i, bx m -> ax i, bx c)
writeableContent  mac 2
                  cmp ax 0
                  jlt subscript_error
                  cmp ax [bx + MAP_LENGTH*BpW]
                  jlt _2
                  cmp ax [bx + MAP_CAPACITY*BpW]
                  jlt _1
                  inv $0
_1                inv $1
                  mvw cx ax
                  inc cx
                  mvw [bx + MAP_LENGTH*BpW] cx
_2                mvw bx [bx + MAP_CONTENTS*BpW]
                  end
\end{verbatim}}



\subsection{Global constants and types}\label{scalars}

The number of threads, established by default or declared by the \texttt{p}-option of the command line, is held in constant \textsc{threads}.\footnote{The \dvmasm\ phrase '@$n$' yields the value of option~$n$ on the command line.}

\begin{tabbing}
\indents
\vb\>\textbf{constant} \textsc{Threads}; \\
\vb\>\textbf{type} \emph{ThreadRange} \textbf{is} \textbf{mod} \textsc{Threads};
\end{tabbing}

{\small
\begin{verbatim}
THREADS  equ  @p
\end{verbatim}}

A thread is idle or busy. Breaking a sacred rule of good programming, the encodings of these constants give a weight of $+1$ to an idle thread and $-1$ to a busy one. See \xs{threadstate} below for exploitation of this felonious device.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{ThreadState} \textbf{is}
   $\textsc{Idle} = +1$ $|$  $\textsc{Busy} = -1$;
\end{tabbing}

{\small
\begin{verbatim}
IDLE     equ +1
BUSY     equ -1
\end{verbatim}}

When a thread has been waiting for something to do, it is restarted for the purpose of carrying out one of three \emph{Actions}: to carry out a (useful) \textsc{Task}, to \textsc{Close} the system down, or to \textsc{Exit}. As with Type~\emph{ThreadState} above, the values representing this enumeration are chosen deviously. (See \xs{threadmonitor}.)

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Action} \textbf{is}
   $\textsc{Exit} = \textsc{False}$ $|$ $\textsc{Task} = \textsc{True}$ $|$ $\textsc{Close} = 2$;
\end{tabbing}

{\small
\begin{verbatim}
EXIT     equ FALSE
TASK     equ TRUE
CLOSE    equ 2
\end{verbatim}}

Threads are created with a stack of modest size for evaluating expressions and for invoking externals.\footnote{We should perhaps make \textsc{StackWords} a command-line argument.}

\begin{tabbing}
\indents
\vb\>\textbf{constant} \textsc{StackWords} \textbf{is} 1024;
\end{tabbing}

{\small
\begin{verbatim}
STACK_WORDS  equ  1024
\end{verbatim}}

Constant global array \emph{threads} holds the addresses of thread control blocks (TCBs).\footnote{Well, it's constant once initialisation is complete.} The array has \emph{\small THREADS+1} elements. The first \emph{\small THREADS} elements hold the TCBs of  threads employed for executing processes. The last element of the array, \emph{threads[{\small THREADS}]}, holds the TCB of the \emph{controller} (see \xs{framework}).

\begin{tabbing}
\indents
\vb\>\textbf{constant} \emph{threads} \textbf{is array} \emph{ThreadRange+1} \textbf{of} \emph{Thread};
\end{tabbing}

{\small
\begin{verbatim}
threads  bss  (THREADS+1) * BpW
\end{verbatim}}

The following invariants enable us to convert from a thread's identifying number (a \emph{ThreadRange}) to its control block and \emph{vice versa}.

\begin{tabbing}
\indents
\vb\>\textbf{assert} $\forall$ \emph{t} $\in$ \emph{Thread}: \emph{threads}[\emph{t.threadID}] = \emph{t}; \\
\vb\>\textbf{assert} $\forall$ \emph{n} $\in$ \emph{ThreadRange}: \emph{threads}[\emph{n}].\emph{threadID} = \emph{n};
\end{tabbing}

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{ThreadHandle} \textbf{is} \emph{Word};
   \>\>\>\>\>\>\>\>\> \rmk\ OS handle on thread\\
\vb\>\textbf{type} \emph{CodeAddress} \textbf{is} \emph{Word};
   \>\>\>\>\>\>\>\>\> \rmk\ address within code region\\
\vb\>\textbf{type} \emph{DataAddress} \textbf{is} \emph{Word};
   \>\>\>\>\>\>\>\>\> \rmk\ address within data region\\
\\[-30pt]
\end{tabbing}

A \emph{Variable} is an item of data in a \desi\ program. It can be of various kinds.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Variable} \textbf{is variant}\\
\vb\>$|$ \emph{Word}         \>\>\>\>\>\>\> \rmk\ \emph{Boolean}, \emph{Byte} or \emph{Word} \\
\vb\>$|$ \emph{Real}         \>\>\>\>\>\>\> \rmk\ \emph{Real} (occupies two words in this realisation)\\
\vb\>$|$ \emph{Text}         \>\>\>\>\>\>\> \rmk\ pointer to \emph{Text}\\
\vb\>$|$ \emph{DataAddress}  \>\>\>\>\>\>\> \rmk\ pointer to map\\
\vb\>\textbf{end};
\end{tabbing}



\subsection{Structured types}\label{structuredtypes}

A thread is managed by a thread control block, of type \emph{Thread}:

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Thread} \textbf{isa} \emph{Block} \textbf{is} \textbf{record}\\
\vb\>\>\emph{idlersLock}: \emph{SpinLock};
   \>\>\>\>\>\>\>\> \rmk\ lock while maintaining idlers tree\\
\vb\>\>\emph{handle}: \emph{ThreadHandle};
   \>\>\>\>\>\>\>\> \rmk\ OS handle\\
\vb\>\>\emph{state}: \emph{ThreadState};
   \>\>\>\>\>\>\>\> \rmk\ \textsc{Opening}, \textsc{Idle}, \textsc{Busy} or \textsc{Closing}\\
\vb\>\>\emph{threadSeed}: \emph{Word};
   \>\>\>\>\>\>\>\> \rmk\ for assigning processes to threads (see \xs{abstractprocesses})\\
\vb\>\>\emph{idlers}: 0 .. \textsc{Threads};
   \>\>\>\>\>\>\>\> \rmk\ count of idling descendants (see \xs{threadstate})\\
\vb\>\>\emph{failures}: \emph{Word};
   \>\>\>\>\>\>\>\> \rmk\ count of failed processes on this thread\\
\vb\>\>\emph{readies}: \emph{ProcessQueue};
   \>\>\>\>\>\>\>\> \rmk\ queue of processes ready to run\\
\vb\>\>\emph{threadID}: \emph{ThreadRange};
   \>\>\>\>\>\>\>\> \rmk\ ID of this thread\\
\vb\>\>\emph{processCount}: \emph{Word};
   \>\>\>\>\>\>\>\> \rmk\ count of processes created on this thread\\
\vb\>\>\emph{channelCount}: \emph{Word};
   \>\>\>\>\>\>\>\> \rmk\ count of channels created on this thread\\
\vb\>\>\emph{work}: \emph{ProcessQueue};
   \>\>\>\>\>\>\>\> \rmk\ queue of processes waiting thread awakening\\
\vb\>\>\emph{threadLock}: \emph{SpinLock};
   \>\>\>\>\>\>\>\> \rmk\ mutex of thread monitor\\
\vb\>\>\emph{threadQueue}: \emph{Condition}
   \>\>\>\>\>\>\>\> \rmk\ condition queue of thread monitor\\
\vb\>\textbf{end};\\
\vb\>\textbf{constant} \textsc{ThreadWords} \textbf{is} 13;
\end{tabbing}

{\small
\begin{verbatim}
IDLERS_LOCK      equ  W0
HANDLE           equ  W1
STATE            equ  W2
THREAD_SEED      equ  W3
IDLERS           equ  W4
FAILURES         equ  W5
READIES          equ  W6
THREAD_ID        equ  W7
PROCESS_COUNT    equ  W8
CHANNEL_COUNT    equ  W9
WORK             equ W10
THREAD_LOCK      equ W11
THREAD_QUEUE     equ W12
THREAD_WORDS     equ  13
\end{verbatim}}


A process is managed by a process frame, of type \emph{Process}:

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Process} \textbf{isa} \emph{Block} \textbf{is} \textbf{record}\\
\vb\>\>\emph{base}: \emph{DataAddress};
   \>\>\>\>\>\>\>\>\>\> \rmk\ saved frame pointer\\
\vb\>\>\emph{link}: \emph{CodeAddress};
   \>\>\>\>\>\>\>\>\>\> \rmk\ saved code link\\
\vb\>\>\emph{srcFile}: \emph{Text};
   \>\>\>\>\>\>\>\>\>\> \rmk\ name of source file\\
\vb\>\>\emph{srcName}: \emph{Text};
   \>\>\>\>\>\>\>\>\>\> \rmk\ name of source component\\
\vb\>\>\emph{srcLine}: \emph{Word};
   \>\>\>\>\>\>\>\>\>\> \rmk\ line number of statement\\
\vb\>\>\emph{owner}: \emph{Thread};
   \>\>\>\>\>\>\>\>\>\> \rmk\ executive thread\\
\vb\>\>\emph{connections}: \emph{Connection};
   \>\>\>\>\>\>\>\>\>\> \rmk\ chain of connections to process \\
\vb\>\>\emph{processID}: \emph{Word};
   \>\>\>\>\>\>\>\>\>\> \rmk\ process ID\\
\vb\>\>\emph{adrCommVar}: \emph{DataAddress};
   \>\>\>\>\>\>\>\>\>\> \rmk\ address of communicating variable\\
\vb\>\>\emph{randomSeed}: \emph{u64};
   \>\>\>\>\>\>\>\>\>\> \rmk\ seed of random-number generator\\
\vb\>\>\emph{processVariables}: \textbf{array of} \emph{Variable};
   \>\>\>\>\>\>\>\>\>\> \rmk\ inputs and locals\\
\vb\>\textbf{end};\\
\vb\>\textbf{constant} \textsc{CoreProcessWords} \textbf{is} 10;
\end{tabbing}

{\small
\begin{verbatim}
BASE                equ  W0
LINK                equ  W1
SRC_FILE            equ  W2
SRC_NAME            equ  W3
SRC_LINE            equ  W4
OWNER               equ  W5
CONNECTIONS         equ  W6
PROCESS_ID          equ  W7
ADR_COMM_VAR        equ  W8
RANDOM_SEED         equ  W9
CORE_PROCESS_WORDS  equ  11
PrcVar              equ CORE_PROCESS_WORDS * BpW
\end{verbatim}}

Processes are queued for servicing.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{ProcessQueue} \textbf{is} \textbf{queue of} \emph{Process};
\end{tabbing}


A \emph{channel} comprises sundry fields followed by an array of \emph{ports}.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Channel} \textbf{isa} \emph{Block} \textbf{is} \textbf{record}\\
\vb\>\>\emph{channelLock}: \emph{SpinLock};
   \>\>\>\>\>\>\>\> \rmk\ lock to protect the channel\\
\vb\>\>\emph{portCount}: \emph{Word};
   \>\>\>\>\>\>\>\> \rmk\ count of ports\\
\vb\>\>\emph{connectionCount}: \emph{Word};
   \>\>\>\>\>\>\>\> \rmk\ count of connections\\
\vb\>\>\emph{channelID}: \emph{Word};
   \>\>\>\>\>\>\>\> \rmk\ channel ID\\
\vb\>\>\emph{ports}: \textbf{array of} \emph{Port}
   \>\>\>\>\>\>\>\> \rmk\ ports of channel\\
\vb\>\textbf{end};\\
\vb\>\textbf{constant} \textsc{CoreChannelWords} \textbf{is} 3;
\end{tabbing}

{\small
\begin{verbatim}
CHANNEL_LOCK        equ  W0
PORT_COUNT          equ  W1
CONNECTION_COUNT    equ  W2
CHANNEL_ID          equ  W3
CORE_CHANNEL_WORDS  equ  4
PORTS               equ  CORE_CHANNEL_WORDS * BpW
\end{verbatim}}



A \emph{port} comprises a pair of queues, one of writers to the port and one of readers. Only one queue can be occupied at a time.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{PortQueue} \textbf{is} \textsc{Readers} $|$ \textsc{Writers} \\
 \vb\>\textbf{type} \emph{Port} \textbf{isa} \emph{Block} \textbf{is} \textbf{record}\\
\vb\>\>\emph{writers}, \emph{readers}: \emph{ProcessQueue}\\
\vb\>\textbf{end}\\
\vb\>\textbf{constant} \textsc{PortWords} \textbf{is} 2;
\end{tabbing}

{\small
\begin{verbatim}
WRITERS     equ  W0
READERS     equ  W1
PORT_WORDS  equ  2
PORT_SIZE   equ  PORT_WORDS*BpW
\end{verbatim}}


A \emph{connection} is between a process and a channel. A process has a list of connections, and each connection identifies a channel accessible to the process.

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Connection} \textbf{isa} \emph{Block} \textbf{is} \textbf{record}\\
\vb\>\>\emph{nextConnection}: \emph{Connection};\\
\vb\>\>\emph{channel}: \emph{Channel}\\
\vb\>\textbf{end};\\
\vb\>\textbf{constant} \textsc{ConnectionWords} \textbf{is} 2;
\end{tabbing}

{\small
\begin{verbatim}
NEXT_CONNECTION   equ  W0
CHANNEL           equ  W1
CONNECTION_WORDS  equ  2
\end{verbatim}}


A \desi\ routine is managed by a routine frame, of type \emph{Routine}:

\begin{tabbing}
\indents
\vb\>\textbf{type} \emph{Routine} \textbf{isa} \emph{Block} \textbf{is} \textbf{record}\\
\vb\>\>\emph{base}: \emph{DataAddress};
   \>\>\>\>\>\>\>\>\>\> \rmk\ saved frame pointer\\
\vb\>\>\emph{link}: \emph{CodeAddress};
   \>\>\>\>\>\>\>\>\>\> \rmk\ saved code link\\
\vb\>\>\emph{srcFile}: \emph{Text};
   \>\>\>\>\>\>\>\>\>\> \rmk\ name of source file\\
\vb\>\>\emph{srcName}: \emph{Text};
   \>\>\>\>\>\>\>\>\>\> \rmk\ name of source component\\
\vb\>\>\emph{srcLine}: \emph{Word};
   \>\>\>\>\>\>\>\>\>\> \rmk\ line number of statement\\
\vb\>\>\emph{routineVariables}: \textbf{array of} \emph{Variable}
   \>\>\>\>\>\>\>\>\>\> \rmk\ inputs, outputs and locals\\
\vb\>\textbf{end};\\
\vb\>\textbf{constant} \textsc{CoreRoutineWords} \textbf{is} 5;
\end{tabbing}

{\small
\begin{verbatim}
CORE_ROUTINE_WORDS  equ  5
RtnVar   equ  CORE_ROUTINE_WORDS * BpW
\end{verbatim}}



\subsection{Threads}\label{abstractthreads}\label{threadstate}

The thread interface comprises routines \emph{new\_thread} and \emph{adjust\_idlers} together with primitive intrinsic \emph{init\_thread} \dots

\begin{tabbing}
\indents
\rem{Initialise t with stack of \emph{s} words and code as function \emph{f(b)}}
\xtn{init\_thread}{t: \key{ref} ThreadHandle; s, f, b: Word} 
\\[-30pt]
\end{tabbing}

{\small
\begin{verbatim}
init_thread    ext "init_thread"
\end{verbatim}}

\dots\ and by some refactored routines:

\begin{tabbing}
\indents
\rem{Yield new thread control block for thread~\emph{n}.}
\rtn{newTCB}{n: ThreadRange $\rightarrow$ t: Thread}
\vb\>\>\emph{Thread} \emph{t} := \emph{Thread}(\emph{dvm\_new\_block}(0, \textsc{ThreadWords})); \\
\vb\>\>\emph{t.threadLock} := \textsc{Unlocked};
   \>\>\>\>\>\>\>\>\>\> \rmk\ initialise thread monitor lock\\
\vb\>\>\emph{t.idlersLock} := \textsc{Unlocked};
   \>\>\>\>\>\>\>\>\>\> \rmk\ initial state\\
\vb\>\>\emph{t.state} := \textsc{Idle};
   \>\>\>\>\>\>\>\>\>\> \rmk\ initial state\\
\vb\>\>\emph{t.threadSeed} := \emph{n};
   \>\>\>\>\>\>\>\>\>\> \rmk\ seed of generator of thread-of-process\\
\vb\>\>\emph{t.idlers} := 0;
   \>\>\>\>\>\>\>\>\>\> \rmk\ idle\\
\vb\>\>\emph{t.failures} := 0;
   \>\>\>\>\>\>\>\>\>\> \rmk\ born in a state of innocent perfection\\
\vb\>\>\emph{t.threadID} := \emph{n};
   \>\>\>\>\>\>\>\>\>\> \rmk\ ID of this thread\\
\vb\>\>\emph{t.processCount} := 0;
   \>\>\>\>\>\>\>\>\>\> \rmk\ this thread has yet to create a process\\
\vb\>\>\emph{t.channelCount} := 0;
   \>\>\>\>\>\>\>\>\>\> \rmk\ this thread has yet to create a channel\\
\vb\>\>\emph{t.readies} := \emph{dvm\_new\_queue(t)};
   \>\>\>\>\>\>\>\>\>\> \rmk\ nothing to do just yet\\
\vb\>\>\emph{t.work} := \emph{dvm\_new\_queue(t)};
   \>\>\>\>\>\>\>\>\>\> \rmk\ queue into which work can be posted\\
\vb\>\>\emph{t.threadQueue} := \emph{new\_condition}()
   \>\>\>\>\>\>\>\>\>\> \rmk\ initialise thread monitor condition\\
\vb\>\textbf{end}.
\end{tabbing}

{\small
\begin{verbatim}
% XCD newTCB(tos n)                                    % [t * n]
newTCB         enter W1                                %  0 1 2
               ext2 dvm_zero_block 0 THREAD_WORDS      %
               mvw bx sp                               % bx stack
               mvw [bx+W0] ax                          % ax t 
               mvw [ax+THREAD_LOCK] UNLOCKED           %
               mvw [ax+IDLERS_LOCK] UNLOCKED           %
               mvw [ax+STATE] IDLE                     %
               mvw cx [bx+W2]                          % cx n
               mvw [ax+THREAD_SEED] cx                 %
               mvw [ax+THREAD_ID] cx                   %
               ext1 dvm_new_queue ax                   %
               mvw bx [sp]                             % bx t
               mvw [bx+READIES] ax                     %
               ext1 dvm_new_queue bx                   %
               mvw bx [sp+W0]                          % bx t
               mvw [bx+WORK] ax                        %
               ext0 new_condition                      %
               mvw bx ax                               % bx new_condition()
               mvw ax [sp+W0]                          % ax t
               mvw [ax+THREAD_QUEUE] bx                %
               leave W1 W3                             %
               end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Discard thread control block t.}
\rtn{discardTCB}{t: Thread}
\vb\>\>\emph{Thread} \emph{t} := \emph{Thread}(\emph{dvm\_new\_block}(0, \textsc{ThreadWords})); \\
\vb\>\>\emph{discard\_queue(t.readies)};\\
\vb\>\>\emph{discard\_queue(t.work)};\\
\rem{In theory we should discard the mutex and condition. In practice we leave this}
\rem{to the OS, mainly because by the time we execute this code some of the threads}
\rem{relating to the conditions may have completed. We could solve this with a barrier,}
\rem{but choose not to do so---at least, for the moment.}
\rem{\emph{discard\_mutex(\&t.threadLock)};}
\rem{\emph{discard\_condition(\&t.threadQueue)};}
\vb\>\>\emph{discard\_block(t)}\\
\vb\>\textbf{end}.
\end{tabbing}

{\small
\begin{verbatim}
% XCD discardTCB(tos t)                                % [* t]
discardTCB     enter W0                                %  0 1
               mvw bx sp                               % bx stack
               mvw cx [bx+W1]                          % cx t
               ext1 dvm_discard_queue [cx+READIES]     %
               mvw bx sp                               % bx stack
               mvw cx [bx+W1]                          % cx t
               ext1 dvm_discard_queue [cx+WORK]        %
               mvw bx sp                               % bx stack
               ext1 dvm_discard_block [bx+W1]          %
               leave W0 W2                             %
               end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Yield new thread number~\emph{n} of \emph{N} as function \emph{f(t)} and with stack-size \emph{s} words.}
\rtn{new\_thread}{n, N: ThreadRange; f: CodeAddress; s: Word $\rightarrow$ t: Thread}
\vb\>\>\emph{Thread} \emph{t} := \emph{newTCB}(\emph{n}); \\
\vb\>\>\emph{t.idlers} := \emph{N \key{if} n = 0 \key{else} 0};
   \>\>\>\>\>\>\>\>\>\> \rmk\ everyone idle\\
\vb\>\>\emph{t.handle := init\_thread}(\emph{s}, \emph{f}, \emph{t})
   \>\>\>\>\>\>\>\>\>\> \rmk\ launch thread as function of \emph{t}\\
\vb\>\textbf{end}.
\end{tabbing}

{\small
\begin{verbatim}
% XCD new_thread(tos n, tot N, tou f, tov s)           % [t * n N f s]
new_thread     enter W1                                %  0 1 2 3 4 5
               inv newTCB [dx+W2]                      % newTCB(n)
               mvw bx sp                               % bx stack
               mvw [bx+W0] ax                          % ax t
               mvw cx [bx+W2]                          % cx n
               cmp cx 0                                %
               jne _1                                  %
               mvw [ax+IDLERS] [bx+W3]                 % dx N
_1             mvw ax [sp+W0]                          % ax t
               ext3 init_thread [bx+W5] [bx+W4] ax     %
               mvw bx [sp+W0]                          % bx t
               mvw [bx+HANDLE] ax                      %
               mvw ax bx                               % ax t
               leave W1 W6                             %
               end
\end{verbatim}}

A thread oscillates between \emph{busy} and \emph{idle} before finally \emph{closing}. Whenever a thread becomes idle we must consider whether this maybe the last of all threads to do so, in which case the program has come to an end. To detect this condition we employ the algorithm described in \textsf{KIWI141008}. Routine \emph{adjust\_idlers} embodies the algorithm, extended to ensure that as the tree of threads is traversed towards its root each control block is locked during adjustment.

\begin{tabbing}
\indents
\rem{Set state of thread \emph{t} to be \emph{s}. In the case of a change to idle or busy, adjust}
\rem{the counts of idlers and return the final count adjusted, otherwise return zero.}
\rtn{adjust\_idlers}{\key{L} t: Thread \key{L};  s: ThreadState $\rightarrow$ n: Word}
\ooooo{\key{assert} Word(s) = $-1$ $\vee$ Word(s) = $+1$;}
\ooooo{\key{assert} s $\ne$ t.state;}
\ooooo{t.state := s;}
\ooooo{lock(t.idlersLock);}
\ooooo{\key{repeat}}
\ooooooo{s += t.idlers;}
\ooooooo{t.idlers := 0;}
\ooooooo{\key{exit repeat if} t.threadID = 0; \texttt{--} exit if at root of thread tree}
\ooooooo{unlock(t.idlersLock);}
\ooooooo{t := threads\emph{[}(t.threadID $-$ 1)/2\emph{]}; \texttt{--} move to parent}
\ooooooo{lock(t.idlersLock)}
\ooooo{\key{until} t.state = \textsc{Busy};}
\ooooo{n := (t.idlers += s);}
\ooooo{unlock(t.idlersLock)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD adjust_idlers(tos t, tot s)                     % [* t s]
bad_adjust     utf "adjust_idlers(t,s): s = t.state"  %
adjust_idlers  enter W0                               %  0 1 2
               mvw ax [dx+W1]                         % ax t
               mvw bx [ax+STATE]                      % bx t.state
               mvw cx [dx+W2]                         % cx d
               assert_not_equal cx bx bad_adjust      % assert s <> t.state
               mvw [ax+STATE] cx                      % t.state := s
               lock [ax+IDLERS_LOCK]                  % lock t.idlers_lock
_1             mvw cx [ax+IDLERS]                     % REPEAT
               add [dx+W2] cx                         %   s += t.idlers
               zer [ax+IDLERS]                        %   t.idlers := 0
               cmp [ax+THREAD_ID] 0                   %   t.threadID ~ 0
               jeq _2                                 %   exit if t.threadID = 0
               unlock [ax+IDLERS_LOCK]                %   unlock t.idlers_lock
               mvw ax [ax+THREAD_ID]                  %   ax t.threadID
               dec ax                                 %   ax t.threadID-1
               asr ax 1                               %   ax (t.threadID-1)/2
               mvw ax [threads + ax*BpW]              %   ax t := threads[ax]
               lock [ax+IDLERS_LOCK]                  %   lock t.idlers_lock
               cmp [ax+STATE] BUSY                    %   t.state ~ BUSY
               jne _1                                 % UNTIL t.state = BUSY
_2             mvw dx [dx+W2]                         % dx s
               add [ax+IDLERS] dx                     % t.idlers += s
               unlock [ax+IDLERS_LOCK]                % unlock t.idlers_lock
               mvw ax [ax+IDLERS]                     % ax n := t.idlers
               leave W0 W3                            %
               end
\end{verbatim}}



\subsection{Thread Monitor}\label{threadmonitor}
Routines \emph{schedule\_process}, \emph{close}, \emph{get\_work} and \emph{any\_work} form a monitor which acts as a feed through which work is funnelled to a thread. When a thread has nothing to do it waits inside the monitor. Variables \emph{threadLock}, \emph{threadQueue} and \emph{work} of Type~\emph{Thread} are variables of the monitor.
In the \dvmasm\ version of the monitor the thread (`\emph{t}' in the code below) is passed to each routine of the monitor as the first parameter. The parameters shown below are in addition to this implicit parameter.

Monitor routine \emph{schedule\_process(p)} adds Process~\emph{p} to the workload of the thread. It does so by adding \emph{p} to the queue of \emph{work} held by the monitor, and then signalling to the thread that there is work to be done. If the thread is idle the signal wakes it up;  the first thing that a woken thread does is to invoke monitor routine \emph{get\_work} to collect the new process. If the thread is busy the new process waits on the work queue until the thread asks for something else to do.

\begin{tabbing}
\indents
\mon{Feed}{t: Thread}
\ooooo{}
\rem{Schedule process \emph{p} for execution or resumption on thread \emph{t}.}
\monrtn{schedule\_process}{p: Process}
\ooooo{dvm\_enter\_monitor(t.threadLock);}
\ooooo{dvm\_write\_queue(t.work, p);}
\ooooo{\key{if} t.state = \textsc{Idle} \key{then}}
\ooooooo{adjust\_idlers(t, \textsc{Busy})}
\ooooo{\key{end};}
\ooooo{signal(t);}
\ooooo{dvm\_leave\_monitor(t.threadLock)}
\finmore
\end{tabbing}

{\small
\begin{verbatim}
% XCD schedule_process(tos t, tot p)                     % [* t p]
schedule_process enter_monitor W0 W1                     %  0 1 2
                 mvw dx sp
                 mvw bx [dx+W1]                          % bx t
                 ext2 dvm_write_queue [bx+WORK] [dx+W2]  %
                 mvw bx [sp+W1]                          % bx t
                 cmp [bx+STATE] IDLE
                 jne _1
                 inv adjust_idlers bx BUSY
_1               signal W1
                 leave_monitor W0 W3 W1
                 end
\end{verbatim}}


Should a thread wake up to discover that there was no more work to be done then that tells it that it is time to close down. Monitor routine \emph{close\_thread()} wakes its thread even though there is nothing in the work queue.

\begin{tabbing}
\indents
\rem{Instruct thread \emph{t} to close down.}
\monrtn{close\_thread}{}
\ooooo{enter\_monitor(0, t);}
\ooooo{\key{assert} t.state = \textsc{Idle} $\wedge$ dvm\_empty\_queue(t.work);}
\ooooo{signal(t);}
\ooooo{leave\_monitor(0, 2, t)}
\finmore
\end{tabbing}

{\small
\begin{verbatim}
% XCD close_thread(tos t)                                % [* t]
bad_idle         utf "close_thread(t): t.state not idle" %
bad_work         utf "close_thread(t): t.work not empty" %
close_thread     enter_monitor W0 W1                     %  0 1
                 mvw bx [sp+W1]                          % bx t
                 assert_equal [bx+STATE] IDLE bad_idle   %
                 mvw bx [sp+W1]                          % bx t
                 ext1 dvm_empty_queue [bx+WORK]          %
                 assert ax bad_work                      %
                 signal W1
                 leave_monitor W0 W2 W1
                 end
\end{verbatim}}

Monitor routine \emph{program\_complete()} returns whether execution is complete. It should be applied to thread zero.

\begin{tabbing}
\indents
\rem{Yield whether execution is complete.}
\monrtn{program\_complete}{$\rightarrow$ complete: Boolean}
\ooooo{enter\_monitor(0, t);}
\ooooo{\key{assert} t.threadID = 0;}
\ooooo{complete := t.idlers = \textsc{Threads};}
\ooooo{leave\_monitor(0, 2, t)}
\finmore
\end{tabbing}

{\small
\begin{verbatim}
prog_comp_error  utf "progam_complete(t), where t.serial <> 0"
% XCD program_complete(tos t)                                   % [* t]
program_complete enter_monitor W0 W1                            %  0 1
                 mvw bx [sp+W1]                                 % bx t
                 assert_zero [bx+THREAD_ID] prog_comp_error
                 mvw ax TRUE
                 cmp [bx+ IDLERS] THREADS
                 jeq _1
                 mvw ax FALSE
_1               leave_monitor W0 W2 W1
                 end
\end{verbatim}}

Monitor routine \emph{get\_work(q)} causes all of the processes waiting on the thread's work queue to be moved to queue~\emph{q}. If the work queue is empty the thread waits inside the monitor until a process is scheduled for work by routine \emph{schedule\_process} or until routine \emph{close\_thread} instructs the thread to close down.

\begin{tabbing}
\indents
\rem{Move processes in work queue of thread to back of \emph{q}. Suspend thread if no work.}
\rem{On resumption, yield the action to be taken.}
\monrtn{get\_work}{q: ProcessQueue $\rightarrow$ c: Action}
\ooooo{enter\_monitor(0, t);}
\ooooo{\key{while} dvm\_empty\_queue(t.work) \key{then}}
\ooooooo{idlers: Word := 0 \key{if} t.state = \textsc{Idle} \key{else} adjust\_idlers(t, \textsc{Idle});}
\ooooooo{\key{if} idlers = \textsc{Threads} \key{then}}
\ooooooooo{c := \textsc{Close};  leave\_monitor(0, 3, t)}
\ooooooo{\key{else}}
\ooooooooo{await(t)}
\ooooooo{\key{end}}
\ooooo{\key{end};}
\ooooo{c := \textsc{Task} \key{if} dvm\_move\_queue(q, t.work) \key{else} \textsc{Exit};}
\ooooo{leave\_monitor(0, 3, t)}
\finmore
\end{tabbing}

{\small
\begin{verbatim}
% XCD get_work(tos t, tot q)                      % [* t q]
get_work         enter_monitor W0 W1              %  0 1 2
_4               mvw bx [sp+W1]                   % bx t
                 cmp_queue_head [bx+WORK]
                 jne _2
                 mvw bx [sp+W1]                   % bx t
                 cmp [bx+STATE] IDLE
                 jeq _1
                 inv adjust_idlers bx IDLE
                 mvw bx ax
                 mvw ax CLOSE
                 cmp bx THREADS
                 jeq _3
_1               await W1
                 jmp _4
_2               mvw dx sp
                 mvw bx [dx+W1]                   % bx t
                 ext2 dvm_move_queue [dx+W2] [bx+WORK]
_3               leave_monitor W0 W3 W1
                 end
\end{verbatim}}

Monitor routine \emph{any\_work} is similar to routine \emph{get\_work} except that it does not wait if the work queue is empty. It is employed when the thread is busy, but happy to incorporate any newly scheduled processes into its queue of ready processes.

\begin{tabbing}
\indents
\rem{Move any processes in work queue of thread to back of \emph{q}.}
\rem{Yield whether resulting q is non-empty.}
\monrtn{any\_work}{q: ProcessQueue $\rightarrow$ e: Boolean}
\ooooo{enter\_monitor(0, t);}
\ooooo{e := dvm\_move\_queue(q, t.work);}
\ooooo{leave\_monitor(0, 3, t)}
\finmore
\end{tabbing}

{\small
\begin{verbatim}
% XCD any_work(tos t, tot q)                             % [* t q]
any_work         enter_monitor W0 W1                     %  0 1 2
                 mvw dx sp
                 mvw bx [dx+W1]                          % bx t
                 ext2 dvm_move_queue [dx+W2] [bx+WORK]
                 leave_monitor W0 W3 W1
                 end
\end{verbatim}}

\begin{tabbing}
\indents
\finmon
\end{tabbing}



\subsection{Control Monitor}
The \emph{Control Monitor}, of which there is only one instance, provides somewhere for the main thread of control---that is, the invocation from the \jit\ compiler---to suspend itself while execution of the \desi\ program takes place.
It might also be the place that console i-o is carried out in a version of the system that serialises console calls rather than employing spin-locks.

Monitor routine \emph{suspend\_control()} suspends the controller.

\begin{tabbing}
\indents
\mon{Control}{t: Thread}
\ooooo{}
\rem{Suspend the controller.}
\monrtn{suspend\_control}{}
\ooooo{dvm\_enter\_monitor(t.threadLock);}
\ooooo{\key{assert} t.threadID = \textsc{Threads};}
\ooooo{await(t);}
\ooooo{dvm\_leave\_monitor(t.threadLock)}
\finmore
\end{tabbing}

{\small
\begin{verbatim}
susp_ctrl_error  utf "suspend_control(t), with t <> THREADS"
% XCD suspend_control(tos t)                                          % [* t]
suspend_control  enter_monitor W0 W1                                  %  0 1
                 mvw bx [sp+W1]                                       % bx t
                 assert_equal [bx+THREAD_ID] THREADS susp_ctrl_error
                 await W1
                 leave_monitor W0 W2 W1
                 end
\end{verbatim}}

Monitor routine \emph{resume\_control()} causes the controller to be resumed. 
It is invoked when execution of all processes has completed.

\begin{tabbing}
\indents
\rem{Resume the controller.}
\monrtn{resume\_control}{}
\ooooo{dvm\_enter\_monitor(t.threadLock);}
\ooooo{\key{assert} t.threadID = \textsc{Threads};}
\ooooo{signal(t);}
\ooooo{dvm\_leave\_monitor(t.threadLock)}
\finmore
\end{tabbing}

{\small
\begin{verbatim}
resu_ctrl_error  utf "resume_control(t), with t <> THREADS"
% XCD suspend_control(tos t)                                          % [* t]
resume_control   enter_monitor W0 W1                                  %  0 1
                 mvw bx [sp+W1]                                       % bx t
                 assert_equal [bx+THREAD_ID] THREADS resu_ctrl_error
                 signal W1
                 leave_monitor W0 W2 W1
                 end
\end{verbatim}}

\begin{tabbing}
\indents
\finmon
\end{tabbing}



\subsection{Schnippets}
Software elements that provide the scheduling aspects of the run-time system are mostly open-coded as macros. Exceptions are inner-level elements that need to refer to the program counter. Such elements are expressed as extracodes so that the counter can be retrieved from the stack.
Some snippets of scheduling code, \emph{schnippets}, are factored out from other elements. Schnippets tend to pass arguments in registers, and often do not protect registers they use; they should be used carefully.

Scheduling schnippets include \emph{port\_ready}, \emph{yield\_me},  and \emph{suspend\_me}.

\begin{tabbing}
\indents
\rem{b is whether queue q of port n of channel c is ready.}
\mac{port\_ready}{c: Channel;  n: Word; q: PortQueue $\rightarrow$ b: Boolean}
\ooooo{\key{with lock} c.channelLock \key{do}}
\ooooooo{b := \key{not} empty\_queue(c.ports[n].q)}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC port_ready(ax c, bx n, $0 q -> bx b)
%portready txt "port_ready: "
port_ready  mac 1
            lock [ax+CHANNEL_LOCK]
            lea bx [ax+PORTS+bx*PORT_SIZE]
            cmp_queue_head [bx+$0]
            bne bx
            mzb bx bx
            %log2 logTI portready bx
            unlock [ax+CHANNEL_LOCK]
            end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Put me to back of queue and return to the executor.}
\rtn{yield\_me}{}
\ooooo{\key{pp}.link := \key{pop};}
\ooooo{\key{pp}.base := \key{bp};}
\ooooo{any\_work(\key{tp}, \key{tp}.readies);}
\ooooo{write\_queue(\key{tp}.readies, \key{pp});}
\ooooo{\key{return} to executor}
\fin
\end{tabbing}

{\small
\begin{verbatim}
%yielding txt "yield_me: "
% XCD yield_me(tos *)
yield_me  pop [pp + LINK]
          %log2 logTT yielding [pp+SRC_NAME]
          mvw [pp + BASE] bp
          inv any_work tp [tp + READIES]
          ext2 dvm_write_queue [tp + READIES] pp
          ret
          end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Queue this process on \emph{t.n}, unlock \emph{c.channelLock}, and return to executor.}
\mac{suspend\_me}{c: Channel; t: Port; n: Word}
\ooooo{\key{pp}.link := \key{pop};}
\ooooo{\key{pp}.base := \key{bp};}
\ooooo{dvm\_write\_queue(t.n, \key{pp});}
\ooooo{unlock(c.channelLock);}
\ooooo{\key{return} to executor}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC suspend_me(ax c, bx t, n)
%smsuspending     txt "suspend_me: suspending "
%bxis             txt "suspend_me: bx is "
%dollarzerois     txt "suspend_me: $0 is "
%queueheadis      txt "suspend_me: [bx+$0] is "
suspend_me       mac 1
                 pop [pp+LINK]
                 mvw [pp+BASE] bp
                 psh ax
                 %log2 logTT smsuspending [pp+SRC_NAME]
                 %log2 logTH bxis bx
                 %log2 logTH dollarzerois $0
                 %log2 logTH queueheadis [bx+$0]
                 ext2 dvm_write_queue [bx+$0] pp
                 pop ax
                 unlock [ax+CHANNEL_LOCK]
                 ret
                 end
\end{verbatim}}


\subsection{Channels}
A process \emph{connects} to a channel either by creating it or by having it passed as an argument. When a process comes to an end, it disconnects from all of the channels it is connected to, whether it created them or had them passed as arguments. Each channel maintains a count of the number of its connections; when the count reaches zero then there exists no software that can interact with it, so its space can be recovered.

This simple logic enables us to manage the storage occupied by channels. There are two subtleties.
\begin{enumerate}
	\item
   The logic relates to a process and is unaffected by the activity of routines that the process invokes. Passing a channel to a routine is neither here nor there. If a routine creates a channel then the connection is assumed to be to the routine's ancestral process.
   \item
   When one process creates another, and passes a newly created channel to it, the creating process bumps the channel count rather than the created process doing so as part of its opening sequence of steps. This is done because it could be that the creating process completes its execution before the created process gets the chance to execute any of its code. In this case the creating process would disconnect from the channel, which would cause the channel's connection count to become zero, and the channel to be discarded too early.
\end{enumerate}

A \emph{connection} is between a process and a channel. Each process has a list of connections, and each connection identifies a channel.
Extracode \texttt{connect(p,c)} creates a connection, stores a reference to channel~\texttt{c} in it, links it to the chain of such connections held by process~\texttt{p}, and bumps the channel's count of such connections. The extracode leaves the values of \texttt{p} and \texttt{c} in registers~\texttt{ax} and \texttt{bx} respectively.
extracode \texttt{disconnect(c)} decrements the count of connections to channel~\texttt{c}. Should the count reach zero, it reclaims the space occupied by the channel.

Channel routines are \emph{create\_channel}, \emph{connect\_channel} and \emph{disconnect\_channel}, as follows.

\begin{tabbing}
\indents
\rem{Connect Process \emph{p} to Channel \emph{c}.}
\rtn{connect\_channel}{c: Channel;  p: Process}
\ooooo{n: Connection := Connection(dvm\_new\_block(p.owner, \textsc{ConnectionWords}));}
\ooooo{n.channel := c;}
\ooooo{c.connectionCount += 1;}
\ooooo{n.nextConnection := p.connections;}
\ooooo{p.connections := n}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD connect_channel(tos c, tot p) [preserve ax]        % [ax * c p]
connect_channel  enter W0                                %   0 1 2 3
                 psh ax
                 mvw bx [sp+W3]                          % bx p
                 ext2 dvm_new_block [bx+OWNER] CONNECTION_WORDS
                 mvw bx [sp+W3]                          % bx p
                 mvw cx [sp+W2]                          % cx c
                 mvw [ax+CHANNEL] cx                     % ax n
                 inc [cx+CONNECTION_COUNT]               %
                 mvw dx [bx+CONNECTIONS]                 %
                 mvw [ax+NEXT_CONNECTION] dx             %
                 mvw [bx+CONNECTIONS] ax
                 pop ax
                 leave W0 W3
                 end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Connect Process \emph{p} to Channel \emph{c}.}
\mac{connectChn}{c: Channel;  p: Process}
\ooooo{connect\_channel(c, p);}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC connectChn(c, p) [preserve ax]
connectChn  mac 2
            inv connect_channel $0 $1
            end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Create channel with \emph{r} ports in Process \emph{p}, with same owner as \emph{p}.}
\rtn{create\_channel}{r: Word;  p: Process $\rightarrow$ c: Channel}
\ooooo{c := Channel(dvm\_new\_block(p.owner, \textsc{CoreChannelWords} + r * \textsc{PortWords}));}
\ooooo{c.channelLock := \textsc{Unlocked};}
\ooooo{c.portCount := r;}
\ooooo{c.connectionCount := 0;}
\ooooo{\key{tp}.channelCount += 1; \rmk\ \emph{no need for lock as \emph{channelCount} is private}}
\ooooo{c.channelID := \key{tp}.channelCount * \textsc{Threads} + \key{tp}.threadID}
\ooooo{\key{for} i \key{from} 0 \key{to} r-1 \key{do}}
\ooooooo{c.ports[i].writers := dvm\_new\_queue(p.owner);}
\ooooooo{c.ports[i].readers := dvm\_new\_queue(p.owner)}
\ooooo{\key{end};}
\ooooo{connect\_channel(c, p)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
%newclannelis     txt "create_Channel: "
% XCD create_channel(tos r, tot p)                       % [t i c * r p]
create_channel   enter W3                                %  0 1 2 3 4 5
                 mvw ax [sp+W4]                          % ax r
                 mul ax PORT_WORDS                       %
                 add ax CORE_CHANNEL_WORDS               %
                 mvw bx [sp+W5]                          % bx p
                 ext2 dvm_new_block [bx+OWNER] ax        % ax c
                 %log2 logTH newclannelis ax
                 mvw [sp+W2] ax                          %
                 mvw [ax+CHANNEL_LOCK] UNLOCKED          %
                 mvw cx [sp+W4]                          % cx r
                 mvw [ax+PORT_COUNT] cx                  %
                 inc [tp+CHANNEL_COUNT]
                 mvw dx [tp+CHANNEL_COUNT]
                 mul dx THREADS
                 add dx [tp+THREAD_ID]
                 mvw [ax+CHANNEL_ID] dx
                 zer [ax+CONNECTION_COUNT]               %
                 zer bx                                  % bx i
_1               mvw [sp+W1] bx                          %
                 lea ax [ax + PORTS + bx*PORT_SIZE]      % ax @c.ports[i]
                 mvw [sp+W0] ax                          %
                 mvw bx [sp+W5]                          % bx p
                 ext1 dvm_new_queue [bx+OWNER]           %
                 mvw bx [sp+W0]                          % bx t
                 mvw [bx+WRITERS] ax                     %
                 mvw bx [sp+W5]                          % bx p
                 ext1 dvm_new_queue [bx+OWNER]           %
                 mvw bx [sp+W0]                          % bx t
                 mvw [bx+READERS] ax                     %
                 mvw bx [sp+W1]                          % bx i
                 inc bx                                  %
                 mvw ax [sp+W2]                          % ax c
                 cmp bx [sp+W4]                          %
                 jne _1                                  %
                 mvw bx [sp+W5]                          % bx p
                 connectChn ax bx                        %
                 mvw ax [sp+W2]                          %
                 leave W3 W6                             %
                 end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Create channel with \emph{r} ports in Process \emph{p}, with same owner as \emph{p}.}
\mac{newChn}{r: Word;  p: Process $\rightarrow$ c: Channel}
\ooooo{c := create\_channel(r, p)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC newChn(r,p)
newChn   mac 2
         inv create_channel $0 $1
         end
\end{verbatim}}


\begin{tabbing}
\indents
\rem{Discard channel \emph{c}.}
\rtn{discard\_channel}{c: Channel}
\ooooo{\key{for} i \key{from} 0 \key{to} c.portCount-1 \key{do}}
\ooooooo{dvm\_discard\_queue(c.ports[i].writers);}
\ooooooo{dvm\_discard\_queue(c.ports[i].readers)}
\ooooo{\key{end};}
\ooooo{dvm\_discard\_block(c)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD discard_channel(tos c)                             % [t i * c]
discard_channel  enter W2                                %  0 1 2 3
                 mvw ax [dx+W3]                          % ax c
                 zer bx                                  % bx i
_1               mvw [sp+W1] bx                          %
                 lea ax [ax + PORTS + bx*PORT_SIZE]      % ax @c.ports[i]
                 mvw [sp+W0] ax                          % ax t
                 ext1 dvm_discard_queue [ax+READERS]     %
                 mvw ax [sp+W0]                          %
                 ext1 dvm_discard_queue [ax+WRITERS]     %
                 mvw bx [sp+W1]                          % bx i
                 inc bx                                  %
                 mvw ax [sp+W3]                          % ax c
                 cmp bx [ax+PORT_COUNT]                  %
                 jne _1                                  %
                 ext1 dvm_discard_block ax               %
                 leave W2 W4                             %
                 end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Discard channel \emph{c}.}
\mac{discardChn}{c: Channel}
\ooooo{discard\_channel(c)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC discardChn(c)
discardChn  mac 1
            inv discard_channel $0
            end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Disconnect Channel \emph{c} from one of its processes.}
\rtn{disconnect\_channel}{c: Channel}
\ooooo{\key{with lock} c.channelLock \key{do}}
\ooooooo{connections: Word := (c.connectionCount --= 1)}
\ooooo{\key{end};}
\ooooo{\key{if} connections = 0 \key{then}}
\ooooooo{discard\_channel(c)}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD disconnect_channel(tos c)                      % [* c]
disconnect_channel  enter W0                         %  0 1
                    mvw bx [dx+W1]                   % bx c
                    lock [bx+CHANNEL_LOCK]           %
                    mvw ax [bx + CONNECTION_COUNT]   %
                    dec ax                           %
                    mvw [bx + CONNECTION_COUNT] ax   %
                    unlock [bx+CHANNEL_LOCK]         %
                    cmp ax 0                         %
                    jne _1                           %
                    inv discard_channel bx           %
_1                  leave W0 W2                      %
                    end
\end{verbatim}}

When a process closes, it invokes \emph{close\_channels} to discard its connections. Should a disconnected channel thereby have its count of processes reduced to zero then the channel is also discarded.

\begin{tabbing}
\indents
\rem{Close connections to Process \emph{p}, discarding unconnected channels.}
\rtn{close\_channels}{p: Process}
\ooooo{\key{while} p.connections $\neq$ 0 \key{do}}
\ooooooo{Connection n := p.connections;}
\ooooooo{p.connections := n.nextConnection;}
\ooooooo{disconnect\_channel(n.channel);}
\ooooooo{dvm\_discard\_block(n)}
\ooooo{\key{end};}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD close_channels(tos p)                            % [n * p]
close_channels enter W1                                %  0 1 2
_1             mvw bx [sp+W2]                          % bx p
               mvw ax [bx+CONNECTIONS]                 % ax n
               cmp ax 0                                %
               jeq _2                                  %
               mvw cx [ax+NEXT_CONNECTION]             %
               mvw [bx+CONNECTIONS] cx                 %
               mvw [sp+W0] ax                          %
               inv disconnect_channel [ax+CHANNEL]     %
               mvw ax [sp+W0]                          %
               ext1 dvm_discard_block ax               %
               jmp _1                                  %
_2             leave W1 W3                             %
               end
\end{verbatim}}



\subsection{Processes}\label{abstractprocesses}


\dvmasm\ supports only one kind of process, a kind that suffices for both \desi\ cells and \desi\ processes. A new process is constructed and launched in three stages. First Routine~\emph{new\_process} is invoked to create a frame, then arguments are added to the frame, and finally Macro \emph{launchPrc} catapults the process into its independent life.

\begin{tabbing}
\indents
\rem{Helper function to do the grunt work of making a process based on thread \emph{r},}
\rem{with code \emph{c}, and \emph{n} words of arguments and local variables.}
\rtn{make\_process}{r: ThreadRange;  c: CodeAddress;  n: Word $\rightarrow$ p: Process}
\ooooo{Thread t := threads[r];}
\ooooo{p := Process(dvm\_new\_block(t, n + \textsc{CoreProcessWords}));}
\ooooo{p.base := DataAddress(p);}
\ooooo{p.link := c;}
\ooooo{p.owner := t;}
\ooooo{p.connections := 0}
\ooooo{p.src\_name := "initial\_name"}
\fin
\end{tabbing}

{\small
\begin{verbatim}
initial_name   txt "initial_name"
% XCD make_process(tos r, tot c, tou n -> ax p)        % [t * r c n]
make_process   enter W1                                %  0 1 2 3 4
               mvw bx [dx+W2]                          % bx r
               mvw cx [threads+bx*BpW]                 % cx t
               mvw [dx+W0] cx                          %
               mvw ax [dx+W4]                          % ax n
               add ax CORE_PROCESS_WORDS               %
               ext2 dvm_new_block cx ax                % ax p
               mvw [ax+BASE] ax                        %
               mvw cx [sp+W3]                          % cx c
               mvw [ax+LINK] cx                        %
               mvw cx [sp+W0]                          % cx t
               mvw [ax+OWNER] cx                       %
               zer [ax+CONNECTIONS]                    %
               mvw [ax+SRC_NAME] initial_name          %
               leave W1 W5                             %
               end
\end{verbatim}}

Routine \emph{new\_process(c,n)} yields a new process with code $c$ and $n$ words of arguments and local variables. It is allocated to a random thread, with which it remains throughout its life.

\begin{tabbing}
\indents
\rem{Yield new process; leave trace fields and process ID for \emph{enterPrc} to set.}
\rtn{new\_process}{c: CodeAddress;  n: Word $\rightarrow$ p: Process}
\ooooo{\key{tp}.threadSeed := (\key{tp}.threadSeed $\times$ 1103515245 $+$ 12345) \& ((1 $<<$ 31) $-$ 1);}
\ooooo{p := make\_process(((\key{tp}.threadSeed $>>$ 16) * \textsc{Threads}) $>>$ 15, c, n)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD new_process(tos c, tot n -> ax p)             % [* c n]
new_process    enter W0                             %  0 1 2
               mvw ax [tp+THREAD_SEED]              % ax := (tp.thread_seed
               mul ax 1103515245                    %        * 1,103,515,245
               add ax 12345                         %        + 12,345)   
               and ax 0x7FFFFFFF                    %     & ((1 << 31) -1);
               mvw [tp+THREAD_SEED] ax              % tp.thread_seed := ax;
               asr ax 16                            % ax p = make_progress(
               mul ax THREADS                       %  ((ax >> 16) * THREADS)
               asr ax 15                            %       >> 15,
               inv make_process ax [dx+W1] [dx+W2]  %  c, n)
_1             leave W0 W3
               end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Yield new process with code \emph{c}, and \emph{n} words of arguments and local variables.}
\rem{Leave trace fields and process ID for \emph{enterPrc} to set.}
\mac{newPrc}{c: CodeAddress;  n: Word $\rightarrow$ p: Process}
\ooooo{p := new\_process(c, n);}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% Mac new_process(c, n -> ax p)
newPrc    mac 2
          inv new_process $0 $1
          end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Launch Process \emph{p}.}
\mac{launchPrc}{p: Process}
\ooooo{schedule\_process(p);}
\ooooo{yield\_me() \rmk\ \emph{defer to something else, possibly the newly created process}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC launchPrc($0 p)
launchPrc  mac 1
           inv schedule_process [$0+OWNER] $0
           %inv yield_me
           end
\end{verbatim}}

The body of a process is enveloped by macros \emph{enterPrc} and \emph{exitPrc}.

\begin{tabbing}
\indents
\rem{Open the current process whose source is file \emph{f}, component \emph{c}, and line \emph{n}.}
\mac{enterPrc}{f, c: Text;  n: Word}
\ooooo{\key{pp}.srcFile := f;}
\ooooo{\key{pp}.srcName := c;}
\ooooo{\key{pp}.srcLine := n;}
\ooooo{\key{tp}.processCount += 1; \rmk\ \emph{no need for lock as \emph{processCount} is private}}
\ooooo{p.processID := \key{tp}.processCount * \textsc{Threads} + \key{tp}.threadID}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC enterPrc($0 f, $1 c, $2 n)
%name_now  txt "Name now "
%processcount txt "process count"
enterPrc  mac 3
          mvw [pp+SRC_FILE] $0
          mvw [pp+SRC_NAME] $1
          %log2 logTT name_now [pp+SRC_NAME]
          mvw [pp+SRC_LINE] $2
          %log2 logTH [pp+SRC_NAME] pp
          %log2 logTI processcount [tp+PROCESS_COUNT]
          inc [tp+PROCESS_COUNT]
          mvw ax [tp+PROCESS_COUNT]
          mul ax THREADS
          add ax [tp+THREAD_ID]
          mvw [pp+PROCESS_ID] ax
          mvw [pp+RANDOM_SEED] ax
          end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Close the current process and relinquish the processor.}
\mac{exitPrc}{}
\ooooo{close\_channels(\key{pp});}
\ooooo{dvm\_discard\_block(\key{pp});}
\ooooo{\key{return} \rmk\ \emph{back to the executor}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC exitPrc()
%processexited txt "exiting "
exitPrc   mac 0
          %log2 logTT processexited [pp+SRC_NAME]
          inv close_channels pp
          ext1 dvm_discard_block pp
          ret
          end
\end{verbatim}}



\subsection{Routines}
The frame of a routine holds linkage and trace information followed by input arguments and space for output results, local variables and temporaries. Although it is of no particular significance, the order in which arguments and variables appear in a frame is that of their order in the \desi\ source, or more precisely, the order in which they appear in the \dil\ source.

A new routine is created, invoked and returned from in five stages:
\begin{enumerate}
	\item Macro \textit{newRtn(n)} is invoked to establish a frame of \textit{n} words of input, output and local variables for the routine, and to return the frame's address in the \texttt{ax} register.
   \item Input arguments are placed into the frame, starting at offset \texttt{\small ROUTINE\_VARIABLES} relative to the \texttt{ax} register.
   \item Macro \textit{launchRtn(t)} is invoked to complete the invocation, where \textit{t} is the address of the routine's code.
   \item Any output arguments are copied out of the routine's frame into the calling routine or process.
   \item Macro \textit{discardRtn} is invoked to release the routine's frame.
\end{enumerate}

{\small
\begin{verbatim}
newRtn  mac 1                      % MAC newRtn(n) -> ax r
        mvw ax $0                  %    r := dvm_new_block(
        add ax CORE_ROUTINE_WORDS  %            tp,
        ext2 dvm_new_block tp ax   %            n + CORE_ROUTINE_WORDS);
        mvw [ax + BASE] bp         %    r.BASE := bp;
        end                        % END.
\end{verbatim}}

{\small
\begin{verbatim}
launchRtn  mac 1   % MAC launchRtn($0 c)
           inv $0  %    invoke code at c
           end     % END.
\end{verbatim}}

{\small
\begin{verbatim}
discardRtn  mac 0                      % MAC discardRtn()
            ext1 dvm_discard_block ax  %    discard routine's frame
            end                        % END.
\end{verbatim}}

The code of a routine is enveloped by macros \texttt{enterRtn} and \texttt{exitRtn}.

{\small
\begin{verbatim}
enterRtn  mac 3                     % MAC enterRtn($0 f, $1 n, $2 l)
          mvw bp ax                 %    bp := r;
          mvw [pp+BASE] ax          %    pp.BASE := r;
          pop [bp+LINK]             %    r.LINK := return;
          mvw [bp+SRC_FILE] $0      %    r.srcFile := f;
          mvw [bp+SRC_NAME] $1      %    r.srcName := n;
          mvw [bp+SRC_LINE] $2      %    r.srcLine := l
          end                       % END.
\end{verbatim}}

{\small
\begin{verbatim}
exitRtn   mac 0                     % MAC exitRtn() -> ax r
          mvw ax bp                 %    r := bp;
          mvw bp [ax+BASE]          %    bp := pp.BASE :=
          mvw [pp+BASE] bp          %       caller's base;
          jmp [ax+LINK]             %    return to caller
          end                       % END.
\end{verbatim}}



\subsection{Exceptions}\label{exceptions}
When a failure such as division by zero occurs, extracode \texttt{fail} is invoked to report the failure, to wind back the layers of routines---producing a trace-back on the way---and to close the offending process. The argument of the extracode is the address of an explanatory \desi\ text such as ``Division by zero.''. There is no return from an invocation of \texttt{fail}.

{\small
\begin{verbatim}
fail             inc [tp + FAILURES  ]     % XCD fail(ax t)
                 ext1 logT ax              %    tp.failures += 1;
_1               cmp bp pp                 %    logT(t);
                 jeq _2                    %    WHILE
                 lea ax [bp + SRC_FILE]    %       bp <> pp
                 ext1 logTrace ax          %    DO
                 mvw bx bp                 %       show routine trace;
                 mvw bp [bx+BASE]          %       r := bp;
                 mvw [pp+BASE] bp          %       bp := pp.BASE := caller's base;
                 ext1 dvm_discard_block bx %       free frame at r
                 jmp _1                    %    END;
_2               lea ax [pp + SRC_FILE]    %    show process trace;
                 ext1 logTrace ax          %
                 dlc 4                     %    discard return link;
                 exitPrc                   %    free process
                 end                       % END.
\end{verbatim}}

Extracode \texttt{assert\_or\_fail(t,b)} invokes \texttt{fail(t)} if \texttt{b} is false.

{\small
\begin{verbatim}
assert_or_fail   cmp bx 0      % XCD assert_or_fail(ax t, bx b)
                 jne _1        %    IF NOT b THEN
                 inv fail      %       fail(t)
_1               ret           %    END
                 end           % END.
\end{verbatim}}

Various failures have their own labels, which should be jumped to rather than invoked.

{\small
\begin{verbatim}
subscript_error_msg  txt "Subscript out of bounds"
subscript_error      mvw ax subscript_error_msg   % LAB subscript_error():
                     inv fail                     %    fail("Subscript error")
                     end                          % END.
\end{verbatim}}



\subsection{Scalar Communication}
The essential logic of sending a message from one process to another is:
\begin{quote}
   \emph{If there is a reader at the nominated port of the nominated channel then unqueue it, write the message to it, and resume it; otherwise join the queue of writers.}
\end{quote}
The logic of receiving a message is:
\begin{quote}
   \emph{If there is a writer at the nominated port of the nominated channel then unqueue it, read the message from it, and resume it; otherwise join the queue of readers.}
\end{quote}
Thus we see that sending and receiving a message are identical operations, with reading and writing interchanged. (Sending and receiving a signal is the same as sending and receiving a message except that no transfer takes place.)

Each communication is carried out by four layers of software.

\begin{enumerate}
	\item
   At the first layer---the innermost---a macro such as \emph{transfer\_word} moves information from one process to another, the two processes having established a rendezvous.
   \item
   The second layer is the pair of macros \emph{send} and \emph{receive}, which coordinate the rendezvous, suspending either sender or receiver if the processes are not ready to communicate. A parameter of these macros is the name of the macro of the first layer which is to be invoked to effect the transfer.
   \item
   The third layer comprises routines such as \emph{snd\_word} (\emph{sic}) which invokes a macro of the second layer with \emph{transfer\_word} (from the first layer) as a parameter. The layer comprises routines rather than macros so that the program counter can be captured when a process is suspended.
   \item
   The fourth layer is a macro such as \emph{send\_word} which provides a convenient interface to the third level.
\end{enumerate}

\subsubsection{Layer 1}
The innermost communication layer provides macros \emph{transfer\_signal} (which does nothing), \emph{transfer\_byte}, \emph{transfer\_word}, \emph{transfer\_real} and \emph{transfer\_text}. The two parameters of each macro are registers containing the addresses of the processes involved in the communication. The effect is to move an item from the second process to the first. The addresses of the item's source and destination are given by field \emph{adrCommVar} of each process. The macros may use registers \texttt{cx} and \texttt{dx} but must preserve \texttt{ax} and \texttt{bx}.

{\small
\begin{verbatim}
% MAC transfer_signal(p, q) -- transfer signal from process q to p
transfer_signal  mac 2
                 nix
                 end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC transfer_byte(p, q) -- transfer byte from process q to p
transfer_byte    mac 2
                 mvw cx [$1+ADR_COMM_VAR]
                 mvb dx [cx]
                 mvw cx [$0+ADR_COMM_VAR]
                 mvb [cx] dx
                 end
\end{verbatim}}

{\small
\begin{verbatim}
%transferringword txt "transferring word "
% MAC transfer_word(p, q) -- transfer word from process q to p
transfer_word    mac 2
                 mvw cx [$1+ADR_COMM_VAR]
                 mvw dx [cx]
                 %log2 logTI transferringword dx
                 mvw cx [$0+ADR_COMM_VAR]
                 mvw [cx] dx
                 end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC transfer_real(p, q) -- transfer real from process q to p
transfer_real    mac 2
                 mvw cx [$1+ADR_COMM_VAR]
                 fld [cx]
                 mvw cx [$0+ADR_COMM_VAR]
                 fst [cx]
                 end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC transfer_text(p, q) -- transfer text from process q to p
transfer_text    mac 2
                 psh ax
                 psh bx
                 mvw dx [$1+ADR_COMM_VAR]
                 mvw cx [$0+ADR_COMM_VAR]
                 ext2 dvm_text_copy [cx] [dx]
                 pop bx
                 pop ax
                 end
\end{verbatim}}


\subsubsection{Layer 2}
Layer~2 comprises macros \emph{send} and \emph{receive}.\footnote{ It is possible to reduce the length of the text of Layer~2 by introducing a macro that does most of the heavy lifting and which \emph{send} and \emph{receive} both invoke. However, the signature of such a shared macro turns out to be rather bizarre, and difficult to express in high-level terms. It seemed clearer to write the two macros out in full.}

\begin{tabbing}
\indents
\rem{Send item to port \emph{n} of channel \emph{c}, using \emph{f(p,q)} to effect transfer.}
\mac{send}{c: Channel; n: Word; f: Macro}
\ooooo{lock(c.channel.lock);}
\ooooo{t: Port := c.ports[n];}
\ooooo{\key{if} empty\_queue(t.readers) \key{then}}
\ooooooo{suspend\_me(c, t, writers)}
\ooooo{\key{else}}
\ooooooo{p: Process := dvm\_read\_queue(t.readers);}
\ooooooo{unlock(c.channelLock);}
\ooooooo{f(p, \key{pp});}
\ooooooo{schedule\_process(p.owner, p)}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
%sendcall         txt "send()"
% MAC send(ax c, bx n, f)
send             mac 1
                 %log1 logT sendcall
                 lock [ax+CHANNEL_LOCK]
                 lea bx [ax+PORTS+bx*PORT_SIZE]
                 cmp_queue_head [bx+READERS]
                 jne _1
                 suspend_me WRITERS
_1               psh ax
                 ext1 dvm_read_queue [bx+READERS]
                 pop bx
                 unlock [bx+CHANNEL_LOCK]
                 $0 ax pp
                 inv schedule_process [ax+OWNER] ax
                 end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Receive item from port \emph{n} of channel \emph{c}, using \emph{f(p,q)} to effect transfer.}
\mac{receive}{c: Channel; n: Word; f: Macro}
\ooooo{lock(c.channel.lock);}
\ooooo{t: Port := c.ports[n];}
\ooooo{\key{if} empty\_queue(t.writers) \key{then}}
\ooooooo{suspend\_me(c, t, readers)}
\ooooo{\key{else}}
\ooooooo{p: Process := dvm\_read\_queue(t.writers);}
\ooooooo{unlock(c.channelLock);}
\ooooooo{f(\key{pp}, p);}
\ooooooo{schedule\_process(p.owner, p)}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
%rcvcall          txt "receive()"
% MAC receive(ax c, bx n, f)
receive          mac 1
                 %log1 logT rcvcall
                 lock [ax+CHANNEL_LOCK]
                 lea bx [ax+PORTS+bx*PORT_SIZE]
                 cmp_queue_head [bx+WRITERS]
                 jne _1
                 suspend_me READERS
_1               psh ax
                 ext1 dvm_read_queue [bx+WRITERS]
                 pop bx
                 unlock [bx+CHANNEL_LOCK]
                 $0 pp ax
                 inv schedule_process [ax+OWNER] ax
                 end
\end{verbatim}}


\subsubsection{Layer 3}
The third layer comprises extracodes to send and receive scalar items to and from a nominated port, \emph{n}, of a nominated channel, \emph{c}.

{\small
\begin{verbatim}
% XCD snd_signal(ax c, bx n)
snd_signal  send transfer_signal
            ret
            end

% XCD rcv_signal(ax c, bx n)
rcv_signal  receive transfer_signal
            ret
            end
\end{verbatim}}

{\small
\begin{verbatim}
% XCD snd_byte(ax c, bx n)
snd_byte    send transfer_byte
            ret
            end

% XCD rcv_byte(ax c, bx n)
rcv_byte    receive transfer_byte
            ret
            end
\end{verbatim}}

{\small
\begin{verbatim}
% XCD snd_word(ax c, bx n)
snd_word    send transfer_word
            ret
            end

% XCD rcv_word(ax c, bx n)
rcv_word    receive transfer_word
            ret
            end
\end{verbatim}}

{\small
\begin{verbatim}
% XCD snd_real(ax c, bx n)
snd_real    send transfer_real
            ret
            end

% XCD rcv_real(ax c, bx n)
rcv_real    receive transfer_real
            ret
            end
\end{verbatim}}

{\small
\begin{verbatim}
% XCD snd_text(ax c, bx n)
snd_text    send transfer_text
            ret
            end

% XCD rcv_text(ax c, bx n)
rcv_text    receive transfer_text
            ret
            end
\end{verbatim}}




\subsubsection{Layer 4}
Layer~4 is similar to Layer~3 except that each invocation is expressed as a macro call in which: the channel, \emph{c}, is selected by an offset within the local frame; the port, \emph{n}, is a constant; and the address of the item of data to be sent or received, \emph{d}, is---like \emph{c}---a frame offset.

{\small
\begin{verbatim}
% MAC send_signal(c, n)
send_signal     mac 2
                mvw ax [bp + $0]
                mvw bx $1
                inv snd_signal
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC receive_signal(c, n)
receive_signal  mac 2
                mvw ax [bp + $0]
                mvw bx $1
                inv rcv_signal
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC send_byte(c, n, d)
send_byte       mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv snd_byte
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC receive_byte(c, n, d)
receive_byte    mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv rcv_byte
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC send_word(c, n, d)
send_word       mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv snd_word
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC receive_word(c, n, d)
receive_word    mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv rcv_word
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC send_real(c, n, d)
send_real       mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv snd_real
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC receive_real(c, n, d)
receive_real    mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv rcv_real
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC send_text(c, n, d)
send_text       mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv snd_text
                end
\end{verbatim}}

{\small
\begin{verbatim}
% MAC receive_text(c, n, d)
receive_text    mac 3
                lea ax [bp + $2]
                mvw [pp+ADR_COMM_VAR] ax
                mvw ax [bp + $0]
                mvw bx $1
                inv rcv_text
                end
\end{verbatim}}



\subsection{Non-scalar Communication}


\subsection{Executor}\label{abstractexecutor}
Every thread executes the same outer-level logic, known as the \emph{executor}, which is a routine whose single parameter is its thread control block.
The executor has two helpers, \emph{work\_til\_done} and \emph{close\_other\_threads}.

\begin{tabbing}
\indents
\rem{This thread's ready queue is non-empty. Keep processing until it is empty.}
\rem{Top up the ready queue with any new arrivals, but do not wait for them.}
\mac{work\_til\_done}{}
\ooooo{\key{repeat}}
\ooooooo{\key{repeat}}
\ooooooooo{\key{pp} := dvm\_read\_queue(\key{tp}.readies);}
\ooooooooo{\key{bp} := \key{pp}.base;}
\ooooooooo{\key{call pp}.link}
\ooooooo{\key{until} dvm\_empty\_queue(\key{tp}.readies)}
\ooooo{\key{while} any\_work(\key{tp}, \key{tp}.readies)}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC work_til_done()
%resumingprocess txt "resuming process "
%threadnum      txt "Thread "
%processq       txt "Process queue: "
work_til_done  mac 0
%_1             log2 logTI processq [tp+THREAD_ID]
%               log2 logPQ processq [tp+READIES]
_1             ext1 dvm_read_queue [tp+READIES]
               mvw pp ax
               %log2 logTT resumingprocess [pp+SRC_NAME]
               mvw bp [ax+BASE]
               inv [ax+LINK]
               cmp_queue_head [tp+READIES]
               jne _1
               inv any_work tp [tp+READIES]
               cmp ax TRUE
               jeq _1
               end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{Instruct other threads to close down. (This thread will close itself.)}
\mac{close\_other\_threads}{}
\ooooo{\key{for} t \key{over} threads \key{such that} t $\neq$ \key{tp} \key{do}}
\ooooooo{close\_thread(t)}
\ooooo{\key{end}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% MAC close_other_threads()
%closingthread txt "closing thread "
close_other_threads  mac 0
                     zer ax                   % ax i
_1                   mvw bx [threads+ax*BpW]  % bx t
                     cmp bx tp
                     jeq _2
                     psh ax
                     %log2 logTI closingthread ax
                     inv close_thread bx
                     pop ax
_2                   inc ax
                     cmp ax THREADS
                     jne _1
                     end
\end{verbatim}}

\begin{tabbing}
\indents
\rem{The \emph{executor} is the framework for each thread. }
\rtn{executor}{t: Thread}
\ooooo{\key{tp} := t;}
\ooooo{\key{loopcase} get\_work(\key{tp}, \key{tp}.readies)}
\ooooo{$|$ \textsc{Work}:}
\ooooooo{work\_til\_done()}
\ooooo{$|$ \textsc{Close}:}
\ooooooo{close\_other\_threads();}
\ooooooo{resume\_control();}
\ooooooo{\key{exit loop}}
\ooooo{$|$ \textsc{Exit}:}
\ooooooo{\key{exit loop}}
\ooooo{\key{end};}
\ooooo{\key{exit thread}}
\fin
\end{tabbing}

{\small
\begin{verbatim}
% XCD executor(tos t)
executor       mvw tp [sp+W1]
               psh bp
_1             inv get_work tp [tp+READIES]
               cmp ax EXIT
               jeq _3
               cmp ax CLOSE
               jeq _2
               work_til_done
               jmp _1
_2             close_other_threads
               inv resume_control [threads + THREADS*BpW]
_3             pop bp
               zer ax
               ret
               end
\end{verbatim}}



\subsection{Controller}\label{framework}

\input ../../run/postfix


